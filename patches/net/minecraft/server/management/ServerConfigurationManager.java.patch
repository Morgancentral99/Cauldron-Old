--- ../src-base/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
+++ ../src-work/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
@@ -6,6 +6,8 @@
 import com.mojang.authlib.GameProfile;
 
 import cpw.mods.fml.common.FMLCommonHandler;
+import cpw.mods.fml.common.network.FMLEmbeddedChannel;
+import cpw.mods.fml.common.network.FMLOutboundHandler;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 import java.io.File;
@@ -58,15 +60,37 @@
 import net.minecraft.world.Teleporter;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldProvider;
+import net.minecraft.world.WorldProviderEnd;
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.WorldSettings;
 import net.minecraft.world.demo.DemoWorldManager;
 import net.minecraft.world.storage.IPlayerFileData;
+import net.minecraftforge.common.DimensionManager;
 import net.minecraftforge.common.chunkio.ChunkIOExecutor;
+import net.minecraftforge.common.network.ForgeMessage;
+import net.minecraftforge.common.network.ForgeNetworkHandler;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+// CraftBukkit start
+import net.minecraft.server.network.NetHandlerLoginServer;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.TravelAgent;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerPortalEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.util.Vector;
+// CraftBukkit end
+
 public abstract class ServerConfigurationManager
 {
     public static final File field_152613_a = new File("banned-players.json");
@@ -82,8 +106,8 @@
     private final UserListOps ops;
     private final UserListWhitelist whiteListedPlayers;
     private final Map field_148547_k;
-    private IPlayerFileData playerNBTManagerObj;
-    private boolean whiteListEnforced;
+    public IPlayerFileData playerNBTManagerObj; // CraftBukkit - private -> public
+    public boolean whiteListEnforced; // CraftBukkit - private -> public
     protected int maxPlayers;
     private int viewDistance;
     private WorldSettings.GameType gameType;
@@ -91,8 +115,16 @@
     private int playerPingIndex;
     private static final String __OBFID = "CL_00001423";
 
+    // CraftBukkit start
+    private CraftServer cserver;
+
     public ServerConfigurationManager(MinecraftServer p_i1500_1_)
     {
+        p_i1500_1_.server = new CraftServer(p_i1500_1_, this);
+        p_i1500_1_.console = org.bukkit.craftbukkit.command.ColouredConsoleSender.getInstance();
+        p_i1500_1_.reader.addCompleter(new org.bukkit.craftbukkit.command.ConsoleCommandCompleter(p_i1500_1_.server));
+        this.cserver = p_i1500_1_.server;
+        // CraftBukkit end
         this.bannedPlayers = new UserListBans(field_152613_a);
         this.bannedIPs = new BanList(field_152614_b);
         this.ops = new UserListOps(field_152615_c);
@@ -131,12 +163,34 @@
             s1 = p_72355_1_.getSocketAddress().toString();
         }
 
-        logger.info(p_72355_2_.getCommandSenderName() + "[" + s1 + "] logged in with entity id " + p_72355_2_.getEntityId() + " at (" + p_72355_2_.posX + ", " + p_72355_2_.posY + ", " + p_72355_2_.posZ + ")");
+        // CraftBukkit - add world to 'logged in' message.
+        logger.info(p_72355_2_.getCommandSenderName() + "[" + s1 + "] logged in with entity id " + p_72355_2_.getEntityId() + " at ([" + p_72355_2_.worldObj.worldInfo.getWorldName() + "] " + p_72355_2_.posX + ", " + p_72355_2_.posY + ", " + p_72355_2_.posZ + ")");
         WorldServer worldserver = this.mcServer.worldServerForDimension(p_72355_2_.dimension);
         ChunkCoordinates chunkcoordinates = worldserver.getSpawnPoint();
         this.func_72381_a(p_72355_2_, (EntityPlayerMP)null, worldserver);
         p_72355_2_.playerNetServerHandler = nethandlerplayserver;
+
+        // CraftBukkit start -- Don't send a higher than 60 MaxPlayer size, otherwise the PlayerInfo window won't render correctly.
+        int maxPlayers = this.getMaxPlayers();
+
+        if (maxPlayers > 60)
+        {
+            maxPlayers = 60;
+        }
+        // CraftBukkit end
+
+        // Cauldron start - send DimensionRegisterMessage to client before attempting to login to a Bukkit dimension
+        if (DimensionManager.isBukkitDimension(p_72355_2_.dimension))
+        {
+            FMLEmbeddedChannel serverChannel = ForgeNetworkHandler.getServerChannel();
+            serverChannel.attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.PLAYER);
+            serverChannel.attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(p_72355_2_);
+            serverChannel.writeOutbound(new ForgeMessage.DimensionRegisterMessage(p_72355_2_.dimension, worldserver.getWorld().getEnvironment().getId()));
+        }
+        // Cauldron end
+
         nethandlerplayserver.sendPacket(new S01PacketJoinGame(p_72355_2_.getEntityId(), p_72355_2_.theItemInWorldManager.getGameType(), worldserver.getWorldInfo().isHardcoreModeEnabled(), worldserver.provider.dimensionId, worldserver.difficultySetting, this.getMaxPlayers(), worldserver.getWorldInfo().getTerrainType()));
+        p_72355_2_.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         nethandlerplayserver.sendPacket(new S3FPacketCustomPayload("MC|Brand", this.getServerInstance().getServerModName().getBytes(Charsets.UTF_8)));
         nethandlerplayserver.sendPacket(new S05PacketSpawnPosition(chunkcoordinates.posX, chunkcoordinates.posY, chunkcoordinates.posZ));
         nethandlerplayserver.sendPacket(new S39PacketPlayerAbilities(p_72355_2_.capabilities));
@@ -145,6 +199,7 @@
         p_72355_2_.func_147099_x().func_150884_b(p_72355_2_);
         this.func_96456_a((ServerScoreboard)worldserver.getScoreboard(), p_72355_2_);
         this.mcServer.func_147132_au();
+        /* CraftBukkit start - login message is handled in the event
         ChatComponentTranslation chatcomponenttranslation;
 
         if (!p_72355_2_.getCommandSenderName().equalsIgnoreCase(s))
@@ -158,6 +213,7 @@
 
         chatcomponenttranslation.getChatStyle().setColor(EnumChatFormatting.YELLOW);
         this.sendChatMsg(chatcomponenttranslation);
+        // CraftBukkit end*/
         this.playerLoggedIn(p_72355_2_);
         nethandlerplayserver.setPlayerLocation(p_72355_2_.posX, p_72355_2_.posY, p_72355_2_.posZ, p_72355_2_.rotationYaw, p_72355_2_.rotationPitch);
         this.updateTimeAndWeatherForPlayer(p_72355_2_, worldserver);
@@ -192,7 +248,7 @@
         }
     }
 
-    protected void func_96456_a(ServerScoreboard p_96456_1_, EntityPlayerMP p_96456_2_)
+    public void func_96456_a(ServerScoreboard p_96456_1_, EntityPlayerMP p_96456_2_) // CraftBukkit - protected -> public
     {
         HashSet hashset = new HashSet();
         Iterator iterator = p_96456_1_.getTeams().iterator();
@@ -225,6 +281,11 @@
 
     public void setPlayerManager(WorldServer[] p_72364_1_)
     {
+        if (this.playerNBTManagerObj != null)
+        {
+            return;    // CraftBukkit
+        }
+
         this.playerNBTManagerObj = p_72364_1_[0].getSaveHandler().getSaveHandler();
     }
 
@@ -248,7 +309,7 @@
 
     public NBTTagCompound readPlayerDataFromFile(EntityPlayerMP p_72380_1_)
     {
-        NBTTagCompound nbttagcompound = this.mcServer.worldServers[0].getWorldInfo().getPlayerNBTTagCompound();
+        NBTTagCompound nbttagcompound = this.mcServer.worlds.get(0).getWorldInfo().getPlayerNBTTagCompound();
         NBTTagCompound nbttagcompound1;
 
         if (p_72380_1_.getCommandSenderName().equals(this.mcServer.getServerOwner()) && nbttagcompound != null)
@@ -281,18 +342,64 @@
 
     public void playerLoggedIn(EntityPlayerMP p_72377_1_)
     {
-        this.sendPacketToAllPlayers(new S38PacketPlayerListItem(p_72377_1_.getCommandSenderName(), true, 1000));
+        cserver.detectListNameConflict(p_72377_1_); // CraftBukkit
+        // this.sendPacketToAllPlayers(new S38PacketPlayerListItem(p_72377_1_.getCommandSenderName(), true, 1000)); // CraftBukkit - replaced with loop below
         this.playerEntityList.add(p_72377_1_);
         WorldServer worldserver = this.mcServer.worldServerForDimension(p_72377_1_.dimension);
+        // CraftBukkit start
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(this.cserver.getPlayer(p_72377_1_), "\u00A7e" + p_72377_1_.getCommandSenderName() + " joined the game.");
+        this.cserver.getPluginManager().callEvent(playerJoinEvent);
+        String joinMessage = playerJoinEvent.getJoinMessage();
+
+        if ((joinMessage != null) && (joinMessage.length() > 0))
+        {
+            for (IChatComponent line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage))
+            {
+                this.mcServer.getConfigurationManager().sendPacketToAllPlayers(new S02PacketChat(line));
+            }
+        }
+
+        this.cserver.onPlayerJoin(playerJoinEvent.getPlayer());
         ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount());
-        worldserver.spawnEntityInWorld(p_72377_1_);
-        this.func_72375_a(p_72377_1_, (WorldServer)null);
+        // CraftBukkit end
 
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (p_72377_1_.worldObj == worldserver && !worldserver.playerEntities.contains(p_72377_1_))
+        {
+            worldserver.spawnEntityInWorld(p_72377_1_);
+            this.func_72375_a(p_72377_1_, (WorldServer) null);
+        }
+
+        // CraftBukkit end
+        // CraftBukkit start - sendAll above replaced with this loop
+        S38PacketPlayerListItem packet = new S38PacketPlayerListItem(p_72377_1_.listName, true, 1000);
+
         for (int i = 0; i < this.playerEntityList.size(); ++i)
         {
-            EntityPlayerMP entityplayermp1 = (EntityPlayerMP)this.playerEntityList.get(i);
-            p_72377_1_.playerNetServerHandler.sendPacket(new S38PacketPlayerListItem(entityplayermp1.getCommandSenderName(), true, entityplayermp1.ping));
+            EntityPlayerMP entityplayermp1 = (EntityPlayerMP) this.playerEntityList.get(i);
+
+            if (entityplayermp1.getBukkitEntity().canSee(p_72377_1_.getBukkitEntity()))
+            {
+                entityplayermp1.playerNetServerHandler.sendPacket(packet);
+            }
         }
+
+        // CraftBukkit end
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            EntityPlayerMP entityplayermp1 = (EntityPlayerMP) this.playerEntityList.get(i);
+
+            // CraftBukkit start
+            if (!p_72377_1_.getBukkitEntity().canSee(entityplayermp1.getBukkitEntity()))
+            {
+                continue;
+            }
+
+            // .name -> .listName
+            p_72377_1_.playerNetServerHandler.sendPacket(new S38PacketPlayerListItem(entityplayermp1.listName, true, entityplayermp1.ping));
+            // CraftBukkit end
+        }
     }
 
     public void updatePlayerPertinentChunks(EntityPlayerMP p_72358_1_)
@@ -300,25 +407,70 @@
         p_72358_1_.getServerForPlayer().getPlayerManager().updatePlayerPertinentChunks(p_72358_1_);
     }
 
+    // Cauldron start - vanilla compatibility
     public void playerLoggedOut(EntityPlayerMP p_72367_1_)
     {
-        FMLCommonHandler.instance().firePlayerLoggedOut(p_72367_1_);
-        p_72367_1_.triggerAchievement(StatList.leaveGameStat);
-        this.writePlayerData(p_72367_1_);
-        WorldServer worldserver = p_72367_1_.getServerForPlayer();
+        disconnect(p_72367_1_);
+    }
+    // Cauldron end
 
-        if (p_72367_1_.ridingEntity != null)
+    public String disconnect(EntityPlayerMP entityplayermp)   // CraftBukkit - return string
+    {
+        entityplayermp.triggerAchievement(StatList.leaveGameStat);
+        // Cauldron start - don't show quit messages for players that haven't actually connected
+        PlayerQuitEvent playerQuitEvent = null;
+        if (entityplayermp.playerNetServerHandler != null)
         {
-            worldserver.removePlayerEntityDangerously(p_72367_1_.ridingEntity);
+            // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+            org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(entityplayermp);
+            playerQuitEvent = new PlayerQuitEvent(this.cserver.getPlayer(entityplayermp), "\u00A7e" + entityplayermp.getCommandSenderName() + " left the game.");
+            this.cserver.getPluginManager().callEvent(playerQuitEvent);
+            entityplayermp.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
+            // CraftBukkit end
+        }
+        // Cauldron end
+        FMLCommonHandler.instance().firePlayerLoggedOut(entityplayermp);
+        this.writePlayerData(entityplayermp);
+        WorldServer worldserver = entityplayermp.getServerForPlayer();
+
+        if (entityplayermp.ridingEntity != null && !(entityplayermp.ridingEntity instanceof EntityPlayerMP))   // CraftBukkit - Don't remove players
+        {
+            worldserver.removePlayerEntityDangerously(entityplayermp.ridingEntity);
             logger.debug("removing player mount");
         }
 
-        worldserver.removeEntity(p_72367_1_);
-        worldserver.getPlayerManager().removePlayer(p_72367_1_);
-        this.playerEntityList.remove(p_72367_1_);
-        this.field_148547_k.remove(p_72367_1_.getUniqueID());
-        net.minecraftforge.common.chunkio.ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount());
-        this.sendPacketToAllPlayers(new S38PacketPlayerListItem(p_72367_1_.getCommandSenderName(), false, 9999));
+        worldserver.removeEntity(entityplayermp);
+        worldserver.getPlayerManager().removePlayer(entityplayermp);
+        this.playerEntityList.remove(entityplayermp);
+        this.field_148547_k.remove(entityplayermp.getCommandSenderName());
+        ChunkIOExecutor.adjustPoolSize(this.getCurrentPlayerCount()); // CraftBukkit
+        // CraftBukkit start - .name -> .listName, replace sendAll with loop
+        // this.sendAll(new PacketPlayOutPlayerInfo(entityplayermp.getName(), false, 9999));
+        S38PacketPlayerListItem packet = new S38PacketPlayerListItem(entityplayermp.listName, false, 9999);
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            EntityPlayerMP entityplayermp1 = (EntityPlayerMP) this.playerEntityList.get(i);
+
+            if (entityplayermp1.getBukkitEntity().canSee(entityplayermp.getBukkitEntity()))
+            {
+                entityplayermp1.playerNetServerHandler.sendPacket(packet);
+            }
+        }
+
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        this.cserver.getScoreboardManager().removePlayer(entityplayermp.getBukkitEntity());
+        // Cauldron start
+        if (playerQuitEvent != null)
+        {
+            return playerQuitEvent.getQuitMessage();
+        }
+        else
+        {
+            return null;
+        }
+        // Cauldron end
+        // CraftBukkit end
     }
 
     public String allowUserToConnect(SocketAddress p_148542_1_, GameProfile p_148542_2_)
@@ -359,6 +511,69 @@
         }
     }
 
+    // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
+    public EntityPlayerMP attemptLogin(NetHandlerLoginServer loginlistener, GameProfile gameprofile, String hostname)
+    {
+        // Instead of kicking then returning, we need to store the kick reason
+        // in the event, check with plugins to see if it's ok, and THEN kick
+        // depending on the outcome.
+        SocketAddress socketaddress = loginlistener.field_147333_a.getSocketAddress();
+        EntityPlayerMP entity = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), gameprofile, new ItemInWorldManager(this.mcServer.worldServerForDimension(0)));
+        Player player = entity.getBukkitEntity();
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.field_147333_a.getRawAddress()).getAddress()); // Spigot
+        String s;
+
+        if (this.bannedPlayers.func_152702_a(gameprofile) && !this.bannedPlayers.func_152683_b(gameprofile).hasBanExpired())
+        {
+            UserListBansEntry banentry = (UserListBansEntry) this.bannedPlayers.func_152683_b(gameprofile);
+            s = "You are banned from this server!\nReason: " + banentry.getBanReason();
+
+            if (banentry.getBanEndDate() != null)
+            {
+                s = s + "\nYour ban will be removed on " + dateFormat.format(banentry.getBanEndDate());
+            }
+
+            // return s;
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
+        }
+        else if (!this.func_152607_e(gameprofile))
+        {
+            // return "You are not white-listed on this server!";
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
+        }
+        else if (this.bannedIPs.func_152708_a(socketaddress) && !this.bannedPlayers.func_152683_b(gameprofile).hasBanExpired())
+        {
+            IPBanEntry ipbanentry = this.bannedIPs.func_152709_b(socketaddress);
+            s = "Your IP address is banned from this server!\nReason: " + ipbanentry.getBanReason();
+
+            if (ipbanentry.getBanEndDate() != null)
+            {
+                s = s + "\nYour ban will be removed on " + dateFormat.format(ipbanentry.getBanEndDate());
+            }
+            // return s;
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
+        }
+        else
+        {
+            // return this.players.size() >= this.maxPlayers ? "The server is full!" : null;
+            if (this.playerEntityList.size() >= this.maxPlayers)
+            {
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
+            }
+        }
+
+        this.cserver.getPluginManager().callEvent(event);
+
+        if (event.getResult() != PlayerLoginEvent.Result.ALLOWED)
+        {
+            loginlistener.func_147322_a(event.getKickMessage());
+            return null;
+        }
+
+        return entity;
+        // CraftBukkit end
+    }
+
     public EntityPlayerMP createPlayerForUser(GameProfile p_148545_1_)
     {
         UUID uuid = EntityPlayer.func_146094_a(p_148545_1_);
@@ -397,83 +612,326 @@
         return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), p_148545_1_, (ItemInWorldManager)object);
     }
 
+    public EntityPlayerMP processLogin(GameProfile gameprofile, EntityPlayerMP player)   // CraftBukkit - added EntityPlayer
+    {
+        ArrayList arraylist = new ArrayList();
+        EntityPlayerMP entityplayermp;
+
+        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        {
+            entityplayermp = (EntityPlayerMP) this.playerEntityList.get(i);
+
+            if (entityplayermp.getCommandSenderName().equalsIgnoreCase(gameprofile.getName()))
+            {
+                arraylist.add(entityplayermp);
+            }
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext())
+        {
+            entityplayermp = (EntityPlayerMP) iterator.next();
+            entityplayermp.playerNetServerHandler.kickPlayerFromServer("You logged in from another location");
+        }
+
+        /* CraftBukkit start
+        Object object;
+
+        if (this.mcServer.isDemo())
+        {
+            object = new DemoWorldManager(this.mcServer.worldServerForDimension(0));
+        }
+        else
+        {
+            object = new ItemInWorldManager(this.mcServer.worldServerForDimension(0));
+        }
+
+        return new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(0), p_148545_1_, (ItemInWorldManager)object);
+        // */
+        return player;
+        // CraftBukkit end
+    }
+
     public EntityPlayerMP respawnPlayer(EntityPlayerMP p_72368_1_, int p_72368_2_, boolean p_72368_3_)
     {
-        World world = mcServer.worldServerForDimension(p_72368_2_);
+        return this.respawnPlayer(p_72368_1_, p_72368_2_, p_72368_3_, null, true);
+    }
+
+    public EntityPlayerMP respawnPlayer(EntityPlayerMP par1EntityPlayerMP, int par2, boolean flag, Location location, boolean avoidSuffocation)
+    {
+        // Cauldron start - handle canRespawnHere for mods
+        World world = mcServer.worldServerForDimension(par2);
+
         if (world == null)
         {
-            p_72368_2_ = 0;
+            par2 = 0;
         }
-        else if (!world.provider.canRespawnHere())
+        else if (!world.provider.canRespawnHere() && ((par2 < -1 || par2 > 1) && !DimensionManager.isBukkitDimension(par2))) // ignore vanilla providers
         {
-            p_72368_2_ = world.provider.getRespawnDimension(p_72368_1_);
+            par2 = world.provider.getRespawnDimension(par1EntityPlayerMP);
         }
-
-        p_72368_1_.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(p_72368_1_);
-        p_72368_1_.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers(p_72368_1_);
-        p_72368_1_.getServerForPlayer().getPlayerManager().removePlayer(p_72368_1_);
-        this.playerEntityList.remove(p_72368_1_);
-        this.mcServer.worldServerForDimension(p_72368_1_.dimension).removePlayerEntityDangerously(p_72368_1_);
-        ChunkCoordinates chunkcoordinates = p_72368_1_.getBedLocation(p_72368_2_);
-        boolean flag1 = p_72368_1_.isSpawnForced(p_72368_2_);
-        p_72368_1_.dimension = p_72368_2_;
+        // Cauldron end
+        // CraftBukkit end
+        par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removePlayerFromTrackers(par1EntityPlayerMP);
+        // par1EntityPlayerMP.getServerForPlayer().getEntityTracker().removeEntityFromAllTrackingPlayers(par1EntityPlayerMP); // CraftBukkit
+        par1EntityPlayerMP.getServerForPlayer().getPlayerManager().removePlayer(par1EntityPlayerMP);
+        this.playerEntityList.remove(par1EntityPlayerMP);
+        this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension).removePlayerEntityDangerously(par1EntityPlayerMP);
+        ChunkCoordinates bedSpawnChunkCoords = par1EntityPlayerMP.getBedLocation(par2);
+        boolean flag1 = par1EntityPlayerMP.isSpawnForced(par2);
+        par1EntityPlayerMP.dimension = par2;
+        /* CraftBukkit start
+        par1EntityPlayerMP.dimension = par2;
         Object object;
 
         if (this.mcServer.isDemo())
         {
-            object = new DemoWorldManager(this.mcServer.worldServerForDimension(p_72368_1_.dimension));
+            object = new DemoWorldManager(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension));
         }
         else
         {
-            object = new ItemInWorldManager(this.mcServer.worldServerForDimension(p_72368_1_.dimension));
+            object = new ItemInWorldManager(this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension));
         }
 
-        EntityPlayerMP entityplayermp1 = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(p_72368_1_.dimension), p_72368_1_.getGameProfile(), (ItemInWorldManager)object);
-        entityplayermp1.playerNetServerHandler = p_72368_1_.playerNetServerHandler;
-        entityplayermp1.clonePlayer(p_72368_1_, p_72368_3_);
-        entityplayermp1.dimension = p_72368_2_;
-        entityplayermp1.setEntityId(p_72368_1_.getEntityId());
-        WorldServer worldserver = this.mcServer.worldServerForDimension(p_72368_1_.dimension);
-        this.func_72381_a(entityplayermp1, p_72368_1_, worldserver);
+        EntityPlayerMP entityplayermp1 = new EntityPlayerMP(this.mcServer, this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension), par1EntityPlayerMP.getGameProfile(), (ItemInWorldManager)object);
+        // */
+        EntityPlayerMP entityplayermp1 = par1EntityPlayerMP;
+        org.bukkit.World fromWorld = entityplayermp1.getBukkitEntity().getWorld();
+        entityplayermp1.playerConqueredTheEnd = false;
+        // CraftBukkit end
+        entityplayermp1.playerNetServerHandler = par1EntityPlayerMP.playerNetServerHandler;
+        entityplayermp1.clonePlayer(par1EntityPlayerMP, flag);
+        entityplayermp1.setEntityId(par1EntityPlayerMP.getEntityId());
+        // WorldServer worldserver = this.mcServer.worldServerForDimension(par1EntityPlayerMP.dimension); // CraftBukkit - handled later
+        // this.func_72381_a(entityplayermp1, par1EntityPlayerMP, worldserver); // CraftBukkit - removed
         ChunkCoordinates chunkcoordinates1;
-
-        if (chunkcoordinates != null)
+        // CraftBukkit start
+        if (location == null)
         {
-            chunkcoordinates1 = EntityPlayer.verifyRespawnCoordinates(this.mcServer.worldServerForDimension(p_72368_1_.dimension), chunkcoordinates, flag1);
+            boolean isBedSpawn = false;
+            // Cauldron start - add compatibility for mods
+            CraftWorld cworld = null;
+            if (world.provider.canRespawnHere()) // Fixes Mystcraft age trapping
+            {
+                cworld = (CraftWorld) mcServer.worldServerForDimension(par2).getWorld();
+                // make sure spawnWorld is set correctly
+                if (cworld != null) par1EntityPlayerMP.spawnWorld = cworld.getName();
+                if (bedSpawnChunkCoords == null) // if there is no current saved bed location, revert to spawnpoint
+                {
+                    location = new Location(cworld, cworld.getSpawnLocation().getX() + 0.5, cworld.getSpawnLocation().getY(), cworld.getSpawnLocation().getZ() + 0.5); // use the spawnpoint as location
+                }
+            }
+            if (cworld == null)
+            {
+                cworld = (CraftWorld) this.mcServer.server.getWorld(par1EntityPlayerMP.spawnWorld);
+            }
+            // Cauldron end
 
-            if (chunkcoordinates1 != null)
+            if (cworld != null && bedSpawnChunkCoords != null)
             {
-                entityplayermp1.setLocationAndAngles((double)((float)chunkcoordinates1.posX + 0.5F), (double)((float)chunkcoordinates1.posY + 0.1F), (double)((float)chunkcoordinates1.posZ + 0.5F), 0.0F, 0.0F);
-                entityplayermp1.setSpawnChunk(chunkcoordinates, flag1);
+                chunkcoordinates1 = EntityPlayer.verifyRespawnCoordinates(cworld.getHandle(), bedSpawnChunkCoords, flag1);
+
+                if (chunkcoordinates1 != null)
+                {
+                    isBedSpawn = true;
+                    location = new Location(cworld, chunkcoordinates1.posX + 0.5, chunkcoordinates1.posY, chunkcoordinates1.posZ + 0.5);
+                }
+                else
+                {
+                    entityplayermp1.setSpawnChunk(null, true);
+                    entityplayermp1.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(0, 0));
+                }
             }
-            else
+
+            if (location == null)
             {
-                entityplayermp1.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(0, 0.0F));
+                cworld = (CraftWorld) this.mcServer.server.getWorlds().get(0);
+                // Cauldron start
+                if (bedSpawnChunkCoords != null)
+                {
+                    isBedSpawn = true;
+                }
+                else
+                {
+                    bedSpawnChunkCoords = cworld.getHandle().getSpawnPoint();
+                    if (bedSpawnChunkCoords == null) bedSpawnChunkCoords = par1EntityPlayerMP.getBedLocation(0);
+                }
+                // Cauldron end
+                location = new Location(cworld, bedSpawnChunkCoords.posX + 0.5, bedSpawnChunkCoords.posY, bedSpawnChunkCoords.posZ + 0.5);
             }
+
+            Player respawnPlayer = this.cserver.getPlayer(entityplayermp1);
+            PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
+            this.cserver.getPluginManager().callEvent(respawnEvent);
+            // Spigot Start
+            if (par1EntityPlayerMP.playerNetServerHandler.isDisconnected())
+            {
+                return par1EntityPlayerMP;
+            }
+
+            // Spigot End
+            location = respawnEvent.getRespawnLocation();
+            par1EntityPlayerMP.reset();
         }
+        else
+        {
+            // Cauldron start - make sure to use bed locations when leaving end if one is found.
+            CraftWorld cworld = (CraftWorld) mcServer.worldServerForDimension(par2).getWorld();
+            location.setWorld(cworld);
+            if (bedSpawnChunkCoords != null && WorldProviderEnd.class.isAssignableFrom(world.provider.getClass()))
+            {
+                chunkcoordinates1 = EntityPlayer.verifyRespawnCoordinates(this.mcServer.worldServerForDimension(entityplayermp1.dimension), bedSpawnChunkCoords, flag1);
 
-        worldserver.theChunkProviderServer.loadChunk((int)entityplayermp1.posX >> 4, (int)entityplayermp1.posZ >> 4);
+                if (chunkcoordinates1 != null)
+                {
+                    location = new Location(cworld, chunkcoordinates1.posX + 0.5, chunkcoordinates1.posY, chunkcoordinates1.posZ + 0.5);
+                }
+                else
+                {
+                    entityplayermp1.setSpawnChunk(null, true);
+                    entityplayermp1.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(0, 0));
+                }
+            }
+            // Cauldron end
+        }
 
-        while (!worldserver.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.boundingBox).isEmpty())
+        WorldServer worldserver = ((CraftWorld) location.getWorld()).getHandle();
+        entityplayermp1.setPositionAndRotation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+        // CraftBukkit end
+        worldserver.theChunkProviderServer.loadChunk((int) entityplayermp1.posX >> 4, (int) entityplayermp1.posZ >> 4);
+
+        while (avoidSuffocation && !worldserver.getCollidingBoundingBoxes(entityplayermp1, entityplayermp1.boundingBox).isEmpty())   // CraftBukkit
         {
             entityplayermp1.setPosition(entityplayermp1.posX, entityplayermp1.posY + 1.0D, entityplayermp1.posZ);
         }
 
-        entityplayermp1.playerNetServerHandler.sendPacket(new S07PacketRespawn(entityplayermp1.dimension, entityplayermp1.worldObj.difficultySetting, entityplayermp1.worldObj.getWorldInfo().getTerrainType(), entityplayermp1.theItemInWorldManager.getGameType()));
+        int actualDimension = worldserver.provider.dimensionId;
+        // Cauldron - change dim for bukkit added dimensions
+        if (DimensionManager.isBukkitDimension(actualDimension))
+        {
+            FMLEmbeddedChannel serverChannel = ForgeNetworkHandler.getServerChannel();
+            serverChannel.attr(FMLOutboundHandler.FML_MESSAGETARGET).set(FMLOutboundHandler.OutboundTarget.PLAYER);
+            serverChannel.attr(FMLOutboundHandler.FML_MESSAGETARGETARGS).set(entityplayermp1);
+            serverChannel.writeOutbound(new ForgeMessage.DimensionRegisterMessage(actualDimension, worldserver.getWorld().getEnvironment().getId()));
+        }
+        // Cauldron end
+        // CraftBukkit start
+        entityplayermp1.playerNetServerHandler.sendPacket(new S07PacketRespawn(actualDimension, worldserver.difficultySetting, worldserver.getWorldInfo().getTerrainType(), entityplayermp1.theItemInWorldManager.getGameType()));
+        entityplayermp1.setWorld(worldserver);
+        entityplayermp1.isDead = false;
+        entityplayermp1.playerNetServerHandler.teleport(new Location(worldserver.getWorld(), entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch));
+        entityplayermp1.setSneaking(false);
         chunkcoordinates1 = worldserver.getSpawnPoint();
-        entityplayermp1.playerNetServerHandler.setPlayerLocation(entityplayermp1.posX, entityplayermp1.posY, entityplayermp1.posZ, entityplayermp1.rotationYaw, entityplayermp1.rotationPitch);
+        // entityplayermp1.playerConnection.a(entityplayermp1.locX, entityplayermp1.locY, entityplayermp1.locZ, entityplayermp1.yaw, entityplayermp1.pitch);
+        // CraftBukkit end
         entityplayermp1.playerNetServerHandler.sendPacket(new S05PacketSpawnPosition(chunkcoordinates1.posX, chunkcoordinates1.posY, chunkcoordinates1.posZ));
         entityplayermp1.playerNetServerHandler.sendPacket(new S1FPacketSetExperience(entityplayermp1.experience, entityplayermp1.experienceTotal, entityplayermp1.experienceLevel));
         this.updateTimeAndWeatherForPlayer(entityplayermp1, worldserver);
         worldserver.getPlayerManager().addPlayer(entityplayermp1);
         worldserver.spawnEntityInWorld(entityplayermp1);
         this.playerEntityList.add(entityplayermp1);
-        entityplayermp1.addSelfToInternalCraftingInventory();
+        // CraftBukkit start - Added from changeDimension
+        this.syncPlayerInventory(entityplayermp1); // Update health, etc...
+        entityplayermp1.sendPlayerAbilities();
+        Iterator iterator = entityplayermp1.getActivePotionEffects().iterator();
+
+        while (iterator.hasNext())
+        {
+            PotionEffect potioneffect = (PotionEffect) iterator.next();
+            entityplayermp1.playerNetServerHandler.sendPacket(new S1DPacketEntityEffect(entityplayermp1.getEntityId(), potioneffect));
+        }
+
+        // entityplayermp1.syncInventory();
+        // CraftBukkit end
         entityplayermp1.setHealth(entityplayermp1.getHealth());
-        FMLCommonHandler.instance().firePlayerRespawnEvent(entityplayermp1);
+
+        // CraftBukkit start - Don't fire on respawn
+        if (fromWorld != location.getWorld())
+        {
+            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent((Player) entityplayermp1.getBukkitEntity(), fromWorld);
+            Bukkit.getServer().getPluginManager().callEvent(event);
+            FMLCommonHandler.instance().firePlayerRespawnEvent(entityplayermp1);
+        }
+
+        // CraftBukkit end
         return entityplayermp1;
     }
 
+    // CraftBukkit start - Replaced the standard handling of portals with a more customised method.
+    public void changeDimension(EntityPlayerMP entityplayermp, int i, TeleportCause cause)
+    {
+        // Cauldron start - Allow Forge hotloading on teleport
+        WorldServer exitWorld = this.mcServer.worldServerForDimension(i);
+
+        Location enter = entityplayermp.getBukkitEntity().getLocation();
+        Location exit = null;
+        boolean useTravelAgent = false; // don't use agent for custom worlds or return from THE_END
+
+        if (exitWorld != null)
+        {
+            if ((cause == TeleportCause.END_PORTAL) && (i == 0))
+            {
+                // THE_END -> NORMAL; use bed if available, otherwise default spawn
+                exit = ((org.bukkit.craftbukkit.entity.CraftPlayer) entityplayermp.getBukkitEntity()).getBedSpawnLocation();
+
+                if (exit == null || ((CraftWorld) exit.getWorld()).getHandle().dimension != 0)
+                {
+                    exit = exitWorld.getWorld().getSpawnLocation();
+                }
+            }
+            else
+            {
+                // NORMAL <-> NETHER or NORMAL -> THE_END
+                exit = this.calculateTarget(enter, exitWorld);
+                useTravelAgent = true;
+            }
+        }
+
+        // Cauldron start - allow for forge mods to be the teleporter
+        TravelAgent agent = null;
+        if (exit != null) {
+            net.minecraft.world.Teleporter teleporter = ((CraftWorld)exit.getWorld()).getHandle().getDefaultTeleporter();
+            if (teleporter instanceof TravelAgent) {
+                agent = (TravelAgent)teleporter;
+            }
+        }
+        if (agent == null) {
+            agent = org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+        }
+        // Cauldron end
+        PlayerPortalEvent event = new PlayerPortalEvent(entityplayermp.getBukkitEntity(), enter, exit, agent, cause);
+        event.useTravelAgent(useTravelAgent);
+        Bukkit.getServer().getPluginManager().callEvent(event);
+
+        if (event.isCancelled() || event.getTo() == null)
+        {
+            return;
+        }
+
+        exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+
+        if (exit == null)
+        {
+            return;
+        }
+
+        exitWorld = ((CraftWorld) exit.getWorld()).getHandle();
+        Vector velocity = entityplayermp.getBukkitEntity().getVelocity();
+        boolean before = exitWorld.theChunkProviderServer.loadChunkOnProvideRequest;
+        exitWorld.theChunkProviderServer.loadChunkOnProvideRequest = true;
+        exitWorld.getDefaultTeleporter().adjustExit(entityplayermp, exit, velocity); // Should be getTravelAgent
+        exitWorld.theChunkProviderServer.loadChunkOnProvideRequest = before;
+        this.respawnPlayer(entityplayermp, exitWorld.dimension, true, exit, false); // Vanilla doesn't check for suffocation when handling portals, so neither should we
+
+        if (entityplayermp.motionX != velocity.getX() || entityplayermp.motionY != velocity.getY() || entityplayermp.motionZ != velocity.getZ())
+        {
+            entityplayermp.getBukkitEntity().setVelocity(velocity);
+        }
+
+        // CraftBukkit end
+    }
+
     public void transferPlayerToDimension(EntityPlayerMP p_72356_1_, int p_72356_2_)
     {
         transferPlayerToDimension(p_72356_1_, p_72356_2_, mcServer.worldServerForDimension(p_72356_2_).getDefaultTeleporter());
@@ -501,12 +959,24 @@
             PotionEffect potioneffect = (PotionEffect)iterator.next();
             p_72356_1_.playerNetServerHandler.sendPacket(new S1DPacketEntityEffect(p_72356_1_.getEntityId(), potioneffect));
         }
+
+        // Cauldron start - fire PlayerChangedWorldEvent for mods that call this method
+        if (worldserver != worldserver1)
+        {
+            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent((Player) p_72356_1_.getBukkitEntity(), worldserver.getWorld());
+            Bukkit.getServer().getPluginManager().callEvent(event);
+        }
+
+        // Cauldron end
         FMLCommonHandler.instance().firePlayerChangedDimensionEvent(p_72356_1_, j, p_72356_2_);
     }
 
     public void transferEntityToWorld(Entity p_82448_1_, int p_82448_2_, WorldServer p_82448_3_, WorldServer p_82448_4_)
     {
-        transferEntityToWorld(p_82448_1_, p_82448_2_, p_82448_3_, p_82448_4_, p_82448_4_.getDefaultTeleporter());
+        // CraftBukkit start - Split into modular functions
+        //transferEntityToWorld(p_82448_1_, p_82448_2_, p_82448_3_, p_82448_4_, p_82448_4_.getDefaultTeleporter());
+        Location exit = this.calculateTarget(p_82448_1_.getBukkitEntity().getLocation(), p_82448_4_);
+        this.repositionEntity(p_82448_1_, exit, true);
     }
 
     public void transferEntityToWorld(Entity p_82448_1_, int p_82448_2_, WorldServer p_82448_3_, WorldServer p_82448_4_, Teleporter teleporter)
@@ -592,6 +1062,197 @@
         p_82448_1_.setWorld(p_82448_4_);
     }
 
+    // Copy of original a(Entity, int, WorldServer, WorldServer) method with only location calculation logic
+    public Location calculateTarget(Location enter, World target)
+    {
+        WorldServer worldserver = ((CraftWorld) enter.getWorld()).getHandle();
+        WorldServer worldserver1 = ((CraftWorld) target.getWorld()).getHandle();
+        int i = worldserver.dimension;
+        double y = enter.getY();
+        float yaw = enter.getYaw();
+        float pitch = enter.getPitch();
+        double d0 = enter.getX();
+        double d1 = enter.getZ();
+        double d2 = 8.0D;
+
+        /*
+        double d3 = entity.locX;
+        double d4 = entity.locY;
+        double d5 = entity.locZ;
+        float f = entity.yaw;
+
+        worldserver.methodProfiler.a("moving");
+        */
+        if (worldserver1.dimension == -1)
+        {
+            d0 /= d2;
+            d1 /= d2;
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        }
+        else if (worldserver1.dimension == 0)
+        {
+            d0 *= d2;
+            d1 *= d2;
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        }
+        else
+        {
+            ChunkCoordinates chunkcoordinates;
+
+            if (i == 1)
+            {
+                // use default NORMAL world spawn instead of target
+                worldserver1 = this.mcServer.worlds.get(0);
+                chunkcoordinates = worldserver1.getSpawnPoint();
+            }
+            else
+            {
+                chunkcoordinates = worldserver1.getEntrancePortalLocation();
+            }
+
+            // Cauldron start - validate chunkcoordinates
+            if (chunkcoordinates != null)
+            {
+                d0 = (double) chunkcoordinates.posX;
+                y = (double) chunkcoordinates.posY;
+                d1 = (double) chunkcoordinates.posZ;
+                yaw = 90.0F;
+                pitch = 0.0F;
+            }
+            // Cauldron end
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        }
+
+        // worldserver.methodProfiler.b();
+        if (i != 1)
+        {
+            // worldserver.methodProfiler.a("placing");
+            d0 = (double) MathHelper.clamp_int((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.clamp_int((int) d1, -29999872, 29999872);
+            /*
+            if (entity.isAlive()) {
+                worldserver1.addEntity(entity);
+                entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+                worldserver1.entityJoinedWorld(entity, false);
+                worldserver1.t().a(entity, d3, d4, d5, f);
+            }
+
+            worldserver.methodProfiler.b();
+            */
+        }
+
+        // entity.spawnIn(worldserver1);
+        return new Location(worldserver1.getWorld(), d0, y, d1, yaw, pitch);
+    }
+
+    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
+    public void repositionEntity(Entity entity, Location exit, boolean portal)
+    {
+        int i = entity.dimension;
+        WorldServer worldserver = (WorldServer) entity.worldObj;
+        WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+        /*
+        double d0 = entity.locX;
+        double d1 = entity.locZ;
+        double d2 = 8.0D;
+        double d3 = entity.locX;
+        double d4 = entity.locY;
+        double d5 = entity.locZ;
+        float f = entity.yaw;
+        */
+        worldserver.theProfiler.startSection("moving");
+        entity.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+        if (entity.isEntityAlive())
+        {
+            worldserver.updateEntityWithOptionalForce(entity, false);
+        }
+
+        /*
+        if (entity.dimension == -1) {
+            d0 /= d2;
+            d1 /= d2;
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        } else if (entity.dimension == 0) {
+            d0 *= d2;
+            d1 *= d2;
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        } else {
+            ChunkCoordinates chunkcoordinates;
+
+            if (i == 1) {
+                chunkcoordinates = worldserver1.getSpawn();
+            } else {
+                chunkcoordinates = worldserver1.getDimensionSpawn();
+            }
+
+            d0 = (double) chunkcoordinates.x;
+            entity.locY = (double) chunkcoordinates.y;
+            d1 = (double) chunkcoordinates.z;
+            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        }
+        */
+        worldserver.theProfiler.endSection();
+
+        if (i != 1)
+        {
+            worldserver.theProfiler.startSection("placing");
+
+            /*
+            d0 = (double) MathHelper.a((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.a((int) d1, -29999872, 29999872);
+            */
+            if (entity.isEntityAlive())
+            {
+                // entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch)
+                // worldserver1.s().a(entity, d3, d4, d5, f);
+                if (portal)
+                {
+                    Vector velocity = entity.getBukkitEntity().getVelocity();
+                    worldserver1.getDefaultTeleporter().adjustExit(entity, exit, velocity); // Should be getTravelAgent
+                    entity.setLocationAndAngles(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+
+                    if (entity.motionX != velocity.getX() || entity.motionY != velocity.getY() || entity.motionZ != velocity.getZ())
+                    {
+                        entity.getBukkitEntity().setVelocity(velocity);
+                    }
+                }
+
+                worldserver1.spawnEntityInWorld(entity);
+                worldserver1.updateEntityWithOptionalForce(entity, false);
+            }
+
+            worldserver.theProfiler.endSection();
+        }
+
+        entity.setWorld(worldserver1);
+        // CraftBukkit end
+    }
+
     public void sendPlayerInfoToAllPlayers()
     {
         if (++this.playerPingIndex > 600)
@@ -599,11 +1260,13 @@
             this.playerPingIndex = 0;
         }
 
+        /* CraftBukkit start - Remove updating of lag to players -- it spams way to much on big servers.
         if (this.playerPingIndex < this.playerEntityList.size())
         {
             EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(this.playerPingIndex);
             this.sendPacketToAllPlayers(new S38PacketPlayerListItem(entityplayermp.getCommandSenderName(), true, entityplayermp.ping));
         }
+        // CraftBukkit end */
     }
 
     public void sendPacketToAllPlayers(Packet p_148540_1_)
@@ -863,14 +1526,29 @@
     {
         for (int j = 0; j < this.playerEntityList.size(); ++j)
         {
-            EntityPlayerMP entityplayermp = (EntityPlayerMP)this.playerEntityList.get(j);
+            EntityPlayerMP entityplayermp = (EntityPlayerMP) this.playerEntityList.get(j);
 
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (p_148543_1_ != null && p_148543_1_ instanceof EntityPlayerMP && !entityplayermp.getBukkitEntity().canSee(((EntityPlayerMP) p_148543_1_).getBukkitEntity()))
+            {
+                continue;
+            }
+
+            // CraftBukkit end
+
             if (entityplayermp != p_148543_1_ && entityplayermp.dimension == p_148543_10_)
             {
                 double d4 = p_148543_2_ - entityplayermp.posX;
                 double d5 = p_148543_4_ - entityplayermp.posY;
                 double d6 = p_148543_6_ - entityplayermp.posZ;
 
+                // Cauldron start - send packets only to players within configured player tracking range)
+                if (p_148543_8_ > org.spigotmc.TrackingRange.getEntityTrackingRange(entityplayermp, 512))
+                {
+                    p_148543_8_ = org.spigotmc.TrackingRange.getEntityTrackingRange(entityplayermp, 512);
+                }
+                // Cauldron end
+
                 if (d4 * d4 + d5 * d5 + d6 * d6 < p_148543_8_ * p_148543_8_)
                 {
                     entityplayermp.playerNetServerHandler.sendPacket(p_148543_11_);
@@ -925,16 +1603,19 @@
 
         if (p_72354_2_.isRaining())
         {
+            // CraftBukkit start - handle player weather
             p_72354_1_.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(1, 0.0F));
             p_72354_1_.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(7, p_72354_2_.getRainStrength(1.0F)));
             p_72354_1_.playerNetServerHandler.sendPacket(new S2BPacketChangeGameState(8, p_72354_2_.getWeightedThunderStrength(1.0F)));
+            p_72354_1_.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
+            // CraftBukkit end
         }
     }
 
     public void syncPlayerInventory(EntityPlayerMP p_72385_1_)
     {
         p_72385_1_.sendContainerToPlayer(p_72385_1_.inventoryContainer);
-        p_72385_1_.setPlayerHealthUpdated();
+        p_72385_1_.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
         p_72385_1_.playerNetServerHandler.sendPacket(new S09PacketHeldItemChange(p_72385_1_.inventory.currentItem));
     }
 
@@ -950,7 +1631,10 @@
 
     public String[] getAvailablePlayerDat()
     {
-        return this.mcServer.worldServers[0].getSaveHandler().getSaveHandler().getAvailablePlayerDat();
+        // Cauldron start - don't crash if the overworld isn't loaded
+        List<WorldServer> worldServers = this.mcServer.worlds;
+        return worldServers.isEmpty() ? new String[0] : worldServers.get(0).getSaveHandler().getSaveHandler().getAvailablePlayerDat(); // CraftBukkit
+        // Cauldron end
     }
 
     public void setWhiteListEnabled(boolean p_72371_1_)
@@ -1019,12 +1703,31 @@
 
     public void removeAllPlayers()
     {
-        for (int i = 0; i < this.playerEntityList.size(); ++i)
+        while (!this.playerEntityList.isEmpty())
         {
-            ((EntityPlayerMP)this.playerEntityList.get(i)).playerNetServerHandler.kickPlayerFromServer("Server closed");
+            // Spigot start
+            EntityPlayerMP p = (EntityPlayerMP) this.playerEntityList.get(0);
+            p.playerNetServerHandler.kickPlayerFromServer(this.mcServer.server.getShutdownMessage());
+
+            if ((!this.playerEntityList.isEmpty()) && (this.playerEntityList.get(0) == p))
+            {
+                this.playerEntityList.remove(0);   // Prevent shutdown hang if already disconnected
+            }
+
+            // Spigot end
         }
     }
 
+    // CraftBukkit start - Support multi-line messages
+    public void sendMessage(IChatComponent[] ichatbasecomponent)
+    {
+        for (IChatComponent component : ichatbasecomponent)
+        {
+            sendChatMsgImpl(component, true);
+        }
+    }
+    // CraftBukkit end
+
     public void sendChatMsgImpl(IChatComponent p_148544_1_, boolean p_148544_2_)
     {
         this.mcServer.addChatMessage(p_148544_1_);
