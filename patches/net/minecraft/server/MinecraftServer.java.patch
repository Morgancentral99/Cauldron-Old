--- ../src-base/minecraft/net/minecraft/server/MinecraftServer.java
+++ ../src-work/minecraft/net/minecraft/server/MinecraftServer.java
@@ -32,6 +32,8 @@
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+import java.util.logging.Level;
+
 import javax.imageio.ImageIO;
 import net.minecraft.command.CommandBase;
 import net.minecraft.command.ICommandManager;
@@ -49,6 +51,7 @@
 import net.minecraft.profiler.PlayerUsageSnooper;
 import net.minecraft.profiler.Profiler;
 import net.minecraft.server.dedicated.DedicatedServer;
+import net.minecraft.server.dedicated.PropertyManager;
 import net.minecraft.server.gui.IUpdatePlayerListBox;
 import net.minecraft.server.management.ServerConfigurationManager;
 import net.minecraft.util.AxisAlignedBB;
@@ -75,21 +78,50 @@
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
+import net.minecraftforge.cauldron.CauldronUtils;
 import net.minecraftforge.common.DimensionManager;
 import net.minecraftforge.common.MinecraftForge;
 import net.minecraftforge.event.world.WorldEvent;
 
+// CraftBukkit start
+import java.io.IOException;
+
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+import net.minecraft.world.chunk.storage.AnvilSaveHandler;
+import org.bukkit.World.Environment;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.craftbukkit.util.Waitable;
+import org.bukkit.event.server.RemoteServerCommandEvent;
+import org.bukkit.event.world.WorldSaveEvent;
+// CraftBukkit end
+// Cauldron start
+import java.util.Map;
+import java.lang.reflect.Constructor;
+import joptsimple.OptionParser;
+import cpw.mods.fml.common.asm.transformers.SideTransformer;
+import net.minecraft.command.ServerCommand;
+import net.minecraft.tileentity.TileEntity;
+import net.minecraft.world.WorldProvider;
+import net.minecraftforge.common.util.EnumHelper;
+
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.block.CraftBlock;
+// Cauldron end
+
 public abstract class MinecraftServer implements ICommandSender, Runnable, IPlayerUsage
 {
     private static final Logger logger = LogManager.getLogger();
     private static MinecraftServer mcServer;
-    private final ISaveFormat anvilConverterForAnvilFile;
+    public ISaveFormat anvilConverterForAnvilFile; // CraftBukkit - private final -> public
     private final PlayerUsageSnooper usageSnooper = new PlayerUsageSnooper("server", this, getSystemTimeMillis());
-    private final File anvilFile;
+    public File anvilFile; // CraftBukkit - private final -> public
     private final List tickables = new ArrayList();
     private final ICommandManager commandManager;
     public final Profiler theProfiler = new Profiler();
-    private final NetworkSystem field_147144_o;
+    private NetworkSystem field_147144_o; // Spigot
     private final ServerStatusResponse field_147147_p = new ServerStatusResponse();
     private final Random field_147146_q = new Random();
     @SideOnly(Side.SERVER)
@@ -130,8 +162,38 @@
     private boolean isGamemodeForced;
     private final MinecraftSessionService field_147143_S;
     private long field_147142_T = 0L;
+
+    // CraftBukkit start
+    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public org.bukkit.craftbukkit.CraftServer server;
+    public static OptionSet options; // Cauldron
+    public org.bukkit.command.ConsoleCommandSender console;
+    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+    public ConsoleReader reader;
+    public static int currentTick = (int)(System.currentTimeMillis() / 50);
+    public final Thread primaryThread;
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    public final double[] recentTps = new double[ 3 ];
+    // Spigot end
+    // Cauldron start
+    public static YamlConfiguration configuration;
+    public static YamlConfiguration commandsConfiguration;
+    public static File configFile;
+    public static File commandFile;
+    public static double currentTps = 0;
+    public static boolean useJline = true;
+    public static boolean useConsole = true;
+    public static boolean callingForgeTick = false;
+    public static List<Class<? extends TileEntity>> bannedTileEntityUpdates = new ArrayList<Class<? extends TileEntity>>();
+    // Cauldron end
     private static final String __OBFID = "CL_00001462";
 
+    // Cauldron start - IntegratedServer requires this
     public MinecraftServer(File p_i45281_1_, Proxy p_i45281_2_)
     {
         mcServer = this;
@@ -141,9 +203,58 @@
         this.commandManager = new ServerCommandManager();
         this.anvilConverterForAnvilFile = new AnvilSaveConverter(p_i45281_1_);
         this.field_147143_S = (new YggdrasilAuthenticationService(p_i45281_2_, UUID.randomUUID().toString())).createMinecraftSessionService();
+        primaryThread = new Thread(this, "Server thread");
     }
+    // Cauldron end
+    
+    public MinecraftServer(OptionSet options, Proxy proxy)   // CraftBukkit - signature file -> OptionSet
+    {
+        mcServer = this;
+        this.serverProxy = proxy;
+        // this.anvilFile = p_i45281_1_; // CraftBukkit
+        // this.field_147144_o = new NetworkSystem(this); // Spigot
+        this.commandManager = new ServerCommandManager();
+        // this.anvilConverterForAnvilFile = new AnvilSaveConverter(p_i45281_1_);  // CraftBukkit - moved to DedicatedServer.init
+        this.field_147143_S = (new YggdrasilAuthenticationService(proxy, UUID.randomUUID().toString())).createMinecraftSessionService();
+        // CraftBukkit start
+        this.options = options;
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null)
+        {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            this.useJline = false; // Cauldron
+        }
 
-    protected abstract boolean startServer() throws IOException;
+        try
+        {
+            this.reader = new ConsoleReader(System.in, System.out);
+            this.reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        }
+        catch (Throwable e)
+        {
+            try
+            {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                this.useJline = false; // Cauldron
+                this.reader = new ConsoleReader(System.in, System.out);
+                this.reader.setExpandEvents(false);
+            }
+            catch (IOException ex)
+            {
+                logger.warn((String) null, ex);
+            }
+        }
+        net.minecraftforge.cauldron.CauldronHooks.enableThreadContentionMonitoring();
+        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+        primaryThread = new Thread(this, "Server thread"); // Moved from main
+    }
+    
+    public abstract PropertyManager getPropertyManager();
+    // CraftBukkit end
+    
+    protected abstract boolean startServer() throws java.net.UnknownHostException; // CraftBukkit - throws UnknownHostException
 
     protected void convertMapIfNeeded(String par1Str)
     {
@@ -164,6 +275,7 @@
                         MinecraftServer.logger.info("Converting... " + par1 + "%");
                     }
                 }
+                
                 @SideOnly(Side.CLIENT)
                 public void resetProgressAndMessage(String par1Str) {}
                 @SideOnly(Side.CLIENT)
@@ -187,10 +299,17 @@
 
     protected void loadAllWorlds(String par1Str, String par2Str, long par3, WorldType par5WorldType, String par6Str)
     {
+        // Cauldron start - register vanilla server commands
+        ServerCommandManager vanillaCommandManager = (ServerCommandManager)this.getCommandManager();
+        vanillaCommandManager.registerVanillaCommands();
+        // Cauldron end
         this.convertMapIfNeeded(par1Str);
         this.setUserMessage("menu.loadingLevel");
-        ISaveHandler isavehandler = this.anvilConverterForAnvilFile.getSaveLoader(par1Str, true);
-        WorldInfo worldinfo = isavehandler.loadWorldInfo();
+        // Cauldron start - SaveHandler/WorldInfo below are not used and must be disabled to prevent FML receiving different handlers for overworld
+        // ISaveHandler isavehandler = this.anvilConverterForAnvilFile.getSaveLoader(par1Str, true);
+        // WorldInfo worldinfo = isavehandler.loadWorldInfo();
+        // Cauldron end
+        /* CraftBukkit start - Removed worldsettings
         WorldSettings worldsettings;
 
         if (worldinfo == null)
@@ -206,12 +325,84 @@
         if (this.enableBonusChest)
         {
             worldsettings.enableBonusChest();
+        }  
+        // */
+
+        WorldSettings worldsettings = new WorldSettings(par3, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), par5WorldType);
+        worldsettings.func_82750_a(par6Str);
+        WorldServer world;
+
+        org.bukkit.generator.ChunkGenerator overWorldGen = this.server.getGenerator(par1Str);
+        WorldServer overWorld = (isDemo() ? new DemoWorldServer(this, new AnvilSaveHandler(server.getWorldContainer(), par2Str, true), par2Str, 0, theProfiler) : new WorldServer(this, new AnvilSaveHandler(server.getWorldContainer(), par2Str, true), par2Str, 0, worldsettings, theProfiler, Environment.getEnvironment(0), overWorldGen));
+        if (overWorldGen != null)
+        {
+            overWorld.getWorld().getPopulators().addAll(overWorldGen.getDefaultPopulators(overWorld.getWorld()));
         }
 
-        WorldServer overWorld = (isDemo() ? new DemoWorldServer(this, isavehandler, par2Str, 0, theProfiler) : new WorldServer(this, isavehandler, par2Str, 0, worldsettings, theProfiler));
-        for (int dim : DimensionManager.getStaticDimensionIDs())
+        for (int dimension : DimensionManager.getStaticDimensionIDs())
         {
-            WorldServer world = (dim == 0 ? overWorld : new WorldServerMulti(this, isavehandler, par2Str, dim, worldsettings, overWorld, theProfiler));
+            String worldType = "";
+            String name = "";
+            String oldName = "";
+            org.bukkit.generator.ChunkGenerator gen = null;
+            // Cauldron start
+            Environment env = Environment.getEnvironment(dimension);
+            if (dimension != 0)
+            {
+                if ((dimension == -1 && !this.getAllowNether()) || (dimension == 1 && !this.server.getAllowEnd()))
+                    continue;
+
+                if (env == null)
+                {
+                    WorldProvider provider = WorldProvider.getProviderForDimension(dimension);
+                    worldType = provider.getClass().getSimpleName().toLowerCase();
+                    worldType = worldType.replace("worldprovider", "");
+                    oldName = "world_" + worldType.toLowerCase();
+                    worldType = worldType.replace("provider", "");
+                    env = Environment.getEnvironment(DimensionManager.getProviderType(provider.getClass()));
+                    name = provider.getSaveFolder();
+                    if (name == null) name = "DIM0";
+                }
+                else 
+                {
+                    worldType = env.toString().toLowerCase();
+                    name = "DIM" + dimension;
+                    oldName = par1Str + "_" + worldType;
+                    oldName = oldName.replaceAll(" ", "_");
+                }
+
+                // check if the world is enabled or not
+                if (!configuration.isBoolean("world-settings." + worldType + ".enabled")) {
+                    configuration.set("world-settings." + worldType + ".enabled", true);
+                }
+                boolean enabled = configuration.getBoolean("world-settings." + worldType + ".enabled");
+                try {
+                    configuration.save(MinecraftServer.configFile);
+                } catch (IOException e) {
+                    e.printStackTrace();
+                }
+                if (!enabled)
+                    continue;
+                // end world enabled check
+
+                gen = this.server.getGenerator(name);
+                worldsettings = new WorldSettings(par3, this.getGameType(), this.canStructuresSpawn(), this.isHardcore(), par5WorldType);
+                worldsettings.func_82750_a(par6Str);
+
+                CauldronUtils.migrateWorlds(worldType, oldName, par1Str, name);
+
+                this.setUserMessage(name);
+            }
+
+            world = (dimension == 0 ? overWorld : new WorldServerMulti(this, new AnvilSaveHandler(server.getWorldContainer(), name, true), name, dimension, worldsettings, overWorld, this.theProfiler, env, gen));
+            // Cauldron end
+            if (gen != null)
+            {
+                world.getWorld().getPopulators().addAll(gen.getDefaultPopulators(world.getWorld()));
+            }
+
+            this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
             world.addWorldAccess(new WorldManager(this, world));
 
             if (!this.isSinglePlayer())
@@ -219,12 +410,31 @@
                 world.getWorldInfo().setGameType(this.getGameType());
             }
 
-            MinecraftForge.EVENT_BUS.post(new WorldEvent.Load(world));
+            this.serverConfigManager.setPlayerManager(this.worlds.toArray(new WorldServer[this.worlds.size()]));
+            // CraftBukkit end
+            MinecraftForge.EVENT_BUS.post(new WorldEvent.Load((World)world)); // Forge
         }
-
-        this.serverConfigManager.setPlayerManager(new WorldServer[]{ overWorld });
         this.func_147139_a(this.func_147135_j());
         this.initialWorldChunkLoad();
+        CraftBlock.dumpMaterials(); // Cauldron
+        // Cauldron start
+        SideTransformer.allowInvalidSide = true;
+        for (Object obj : TileEntity.classToNameMap.entrySet())
+        {
+            Map.Entry<Class<? extends TileEntity>, String> tileEntry = (Map.Entry<Class<? extends TileEntity>, String>)obj;
+            if (tileEntry.getKey() == null)
+                continue;
+            // verify if TE's should tick
+            if (!CauldronUtils.isOverridingUpdateEntity(tileEntry.getKey()) && CauldronUtils.canTileEntityUpdate(tileEntry.getKey()))
+            {
+                bannedTileEntityUpdates.add(tileEntry.getKey());
+            }
+            //  register TE's for inventory events
+            EnumHelper.addInventoryType(tileEntry.getKey(), tileEntry.getValue());
+        }
+        CauldronUtils.dumpAndSortClassList(bannedTileEntityUpdates);
+        SideTransformer.allowInvalidSide = false;
+        // Cauldron end
     }
 
     protected void initialWorldChunkLoad()
@@ -236,9 +446,12 @@
         int i = 0;
         this.setUserMessage("menu.generatingTerrain");
         byte b0 = 0;
+        // Cauldron start - we now handle CraftBukkit's keepSpawnInMemory logic in DimensionManager. Prevents crashes with mods such as DivineRPG and speeds up server startup time by a ton.
         logger.info("Preparing start region for level " + b0);
         WorldServer worldserver = this.worldServers[b0];
         ChunkCoordinates chunkcoordinates = worldserver.getSpawnPoint();
+        boolean before = worldserver.theChunkProviderServer.loadChunkOnProvideRequest;
+        worldserver.theChunkProviderServer.loadChunkOnProvideRequest = true;
         long j = getSystemTimeMillis();
 
         for (int k = -192; k <= 192 && this.isServerRunning(); k += 16)
@@ -257,7 +470,8 @@
                 worldserver.theChunkProviderServer.loadChunk(chunkcoordinates.posX + k >> 4, chunkcoordinates.posZ + l >> 4);
             }
         }
-
+        worldserver.theChunkProviderServer.loadChunkOnProvideRequest = before;
+        // Cauldron end
         this.clearCurrentTask();
     }
 
@@ -282,19 +496,17 @@
     {
         this.currentTask = null;
         this.percentDone = 0;
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
     }
 
-    protected void saveAllWorlds(boolean par1)
+    protected void saveAllWorlds(boolean par1) throws MinecraftException   // CraftBukkit - added throws
     {
         if (!this.worldIsBeingDeleted)
         {
-            WorldServer[] aworldserver = this.worldServers;
-            if (aworldserver == null) return; //Forge: Just in case, NPE protection as it has been encountered.
-            int i = aworldserver.length;
-
-            for (int j = 0; j < i; ++j)
+            // CraftBukkit start
+            for (int j = 0; j < this.worlds.size(); ++j)
             {
-                WorldServer worldserver = aworldserver[j];
+                WorldServer worldserver = this.worlds.get(j);
 
                 if (worldserver != null)
                 {
@@ -303,16 +515,20 @@
                         logger.info("Saving chunks for level \'" + worldserver.getWorldInfo().getWorldName() + "\'/" + worldserver.provider.getDimensionName());
                     }
 
-                    try
+                    worldserver.saveAllChunks(true, (IProgressUpdate) null);
+                    worldserver.flush();
+                    WorldSaveEvent event = new WorldSaveEvent(worldserver.getWorld());
+                    this.server.getPluginManager().callEvent(event);
+                    // Cauldron start - save world config
+                    if (worldserver.cauldronConfig != null)
                     {
-                        worldserver.saveAllChunks(true, (IProgressUpdate)null);
+                        worldserver.cauldronConfig.save();
                     }
-                    catch (MinecraftException minecraftexception)
-                    {
-                        logger.warn(minecraftexception.getMessage());
-                    }
+                    // Cauldron end
                 }
             }
+
+            // CraftBukkit end
         }
     }
 
@@ -322,6 +538,14 @@
         {
             logger.info("Stopping server");
 
+            // CraftBukkit start
+            if (this.server != null)
+            {
+                this.server.disablePlugins();
+            }
+
+            // CraftBukkit end
+
             if (this.func_147137_ag() != null)
             {
                 this.func_147137_ag().terminateEndpoints();
@@ -335,19 +559,21 @@
             }
 
             logger.info("Saving worlds");
-            this.saveAllWorlds(false);
-
-            for (int i = 0; i < this.worldServers.length; ++i)
+            try
             {
-                WorldServer worldserver = this.worldServers[i];
-                MinecraftForge.EVENT_BUS.post(new WorldEvent.Unload(worldserver));
-                worldserver.flush();
+                this.saveAllWorlds(false);
             }
+            catch (MinecraftException e)
+            {
+                e.printStackTrace();
+            }
 
-            WorldServer[] tmp = worldServers;
-            for (WorldServer world : tmp)
+            for (int i = 0; i < this.worlds.size(); ++i)
             {
-                DimensionManager.setWorld(world.provider.dimensionId, null);
+                WorldServer worldserver = this.worlds.get(i);
+                MinecraftForge.EVENT_BUS.post(new WorldEvent.Unload(worldserver));
+                // worldserver.flush();
+                DimensionManager.setWorld(worldserver.provider.dimensionId, (WorldServer)null);
             }
 
             if (this.usageSnooper.isSnooperRunning())
@@ -367,6 +593,13 @@
         this.serverRunning = false;
     }
 
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps)
+    {
+        return (avg * exp) + (tps * (1 - exp));
+    }
+    // Spigot End
+
     public void run()
     {
         try
@@ -375,49 +608,47 @@
             {
                 FMLCommonHandler.instance().handleServerStarted();
                 long i = getSystemTimeMillis();
-                long l = 0L;
+                long j = 0L;
                 this.field_147147_p.func_151315_a(new ChatComponentText(this.motd));
                 this.field_147147_p.func_151321_a(new ServerStatusResponse.MinecraftProtocolVersionIdentifier("1.7.2", 4));
                 this.func_147138_a(this.field_147147_p);
+                DedicatedServer.allowPlayerLogins = true; // Cauldron - server is ready, allow player logins
+                // Spigot start
+                Arrays.fill(recentTps, 20);
+                long lastTick = 0, catchupTime = 0, curTime, wait;
 
                 while (this.serverRunning)
                 {
-                    long j = getSystemTimeMillis();
-                    long k = j - i;
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
 
-                    if (k > 2000L && i - this.timeOfLastWarning >= 15000L)
+                    if (wait > 0)
                     {
-                        logger.warn("Can\'t keep up! Did the system time change, or is the server overloaded? Running {}ms behind, skipping {} tick(s)", new Object[] {Long.valueOf(k), Long.valueOf(k / 50L)});
-                        k = 2000L;
-                        this.timeOfLastWarning = i;
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
                     }
-
-                    if (k < 0L)
+                    else
                     {
-                        logger.warn("Time ran backwards! Did the system time change?");
-                        k = 0L;
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
                     }
 
-                    l += k;
-                    i = j;
-
-                    if (this.worldServers[0].areAllPlayersAsleep())
+                    if (MinecraftServer.currentTick++ % 100 == 0)
                     {
-                        this.tick();
-                        l = 0L;
+                        currentTps = 1E9 / (curTime - lastTick);
+                        recentTps[0] = calcTps(recentTps[0], 0.92, currentTps);   // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps(recentTps[1], 0.9835, currentTps);   // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps(recentTps[2], 0.9945, currentTps);   // 1/exp(5sec/15min)
                     }
-                    else
-                    {
-                        while (l > 50L)
-                        {
-                            l -= 50L;
-                            this.tick();
-                        }
-                    }
 
-                    Thread.sleep(1L);
+                    lastTick = curTime;
+                    SpigotTimings.serverTickTimer.startTiming();
+                    this.tick();
+                    SpigotTimings.serverTickTimer.stopTiming();
                     this.serverIsRunning = true;
                 }
+
+                // Spigot end
                 FMLCommonHandler.instance().handleServerStopping();
                 FMLCommonHandler.instance().expectServerStopped(); // has to come before finalTick to avoid race conditions
             }
@@ -435,6 +666,14 @@
         catch (Throwable throwable1)
         {
             logger.error("Encountered an unexpected exception", throwable1);
+
+            // Spigot Start
+            if (throwable1.getCause() != null)
+            {
+                logger.error("\tCause of unexpected exception was", throwable1.getCause());
+            }
+
+            // Spigot End
             CrashReport crashreport = null;
 
             if (throwable1 instanceof ReportedException)
@@ -464,6 +703,7 @@
         {
             try
             {
+                org.spigotmc.WatchdogThread.doStop(); // Spigot
                 this.stopServer();
                 this.serverStopped = true;
             }
@@ -473,6 +713,16 @@
             }
             finally
             {
+                // CraftBukkit start - Restore terminal to original settings
+                try
+                {
+                    this.reader.getTerminal().restore();
+                }
+                catch (Exception e)
+                {
+                }
+
+                // CraftBukkit end
                 FMLCommonHandler.instance().handleServerStopped();
                 this.serverStopped = true;
                 this.systemExitNow();
@@ -517,7 +767,9 @@
     {
         long i = System.nanoTime();
         AxisAlignedBB.getAABBPool().cleanPool();
+        callingForgeTick = true; // Cauldron start - handle loadOnProviderRequests during forge tick event
         FMLCommonHandler.instance().onPreServerTick();
+        callingForgeTick = false; // Cauldron end
         ++this.tickCounter;
 
         if (this.startProfiling)
@@ -546,11 +798,18 @@
             this.field_147147_p.func_151318_b().func_151330_a(agameprofile);
         }
 
-        if (this.tickCounter % 900 == 0)
+        if ((this.autosavePeriod > 0) && ((this.tickCounter % this.autosavePeriod) == 0))   // CraftBukkit
         {
             this.theProfiler.startSection("save");
             this.serverConfigManager.saveAllPlayerData();
-            this.saveAllWorlds(true);
+            try
+            {
+                this.saveAllWorlds(true);
+            }
+            catch (MinecraftException e)
+            {
+                e.printStackTrace();
+            }
             this.theProfiler.endSection();
         }
 
@@ -559,25 +818,51 @@
         this.theProfiler.endSection();
         this.theProfiler.startSection("snooper");
 
-        if (!this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)
+        if (isSnooperEnabled() && !this.usageSnooper.isSnooperRunning() && this.tickCounter > 100)   // Spigot
         {
             this.usageSnooper.startSnooper();
         }
 
-        if (this.tickCounter % 6000 == 0)
+        if (isSnooperEnabled() && this.tickCounter % 6000 == 0)   // Spigot
         {
             this.usageSnooper.addMemoryStatsToSnooper();
         }
 
         this.theProfiler.endSection();
         this.theProfiler.endSection();
+        callingForgeTick = true; // Cauldron start - handle loadOnProviderRequests during forge tick event
         FMLCommonHandler.instance().onPostServerTick();
+        callingForgeTick = false; // Cauldron end
     }
 
     public void updateTimeLightAndEntities()
     {
         this.theProfiler.startSection("levels");
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        // CraftBukkit start
+        this.server.getScheduler().mainThreadHeartbeat(this.tickCounter);
+
+        // Run tasks that are waiting on processing
+        while (!processQueue.isEmpty())
+        {
+            processQueue.remove().run();
+        }
+
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
         net.minecraftforge.common.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.tickCounter % 20 == 0)
+        {
+            for (int i = 0; i < this.getConfigurationManager().playerEntityList.size(); ++i)
+            {
+                EntityPlayerMP entityplayermp = (EntityPlayerMP) this.getConfigurationManager().playerEntityList.get(i);
+                entityplayermp.playerNetServerHandler.sendPacket(new S03PacketTimeUpdate(entityplayermp.worldObj.getTotalWorldTime(), entityplayermp.getPlayerTime(), entityplayermp.worldObj.getGameRules().getGameRuleBooleanValue("doDaylightCycle"))); // Add support for per player time
+            }
+        }
+
         int i;
 
         Integer[] ids = DimensionManager.getIDs(this.tickCounter % 200 == 0);
@@ -586,20 +871,21 @@
             int id = ids[x];
             long j = System.nanoTime();
 
-            if (id == 0 || this.getAllowNether())
-            {
+            //if (id == 0 || this.getAllowNether())
+            //{
                 WorldServer worldserver = DimensionManager.getWorld(id);
                 this.theProfiler.startSection(worldserver.getWorldInfo().getWorldName());
                 this.theProfiler.startSection("pools");
                 worldserver.getWorldVec3Pool().clear();
                 this.theProfiler.endSection();
-
+                /* Drop global time updates
                 if (this.tickCounter % 20 == 0)
                 {
                     this.theProfiler.startSection("timeSync");
                     this.serverConfigManager.sendPacketToAllPlayersInDimension(new S03PacketTimeUpdate(worldserver.getTotalWorldTime(), worldserver.getWorldTime(), worldserver.getGameRules().getGameRuleBooleanValue("doDaylightCycle")), worldserver.provider.dimensionId);
                     this.theProfiler.endSection();
                 }
+                // CraftBukkit end */
 
                 this.theProfiler.startSection("tick");
                 FMLCommonHandler.instance().onPreWorldTick(worldserver);
@@ -611,7 +897,17 @@
                 }
                 catch (Throwable throwable1)
                 {
-                    crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
+                    // Spigot Start
+                    try
+                    {
+                        crashreport = CrashReport.makeCrashReport(throwable1, "Exception ticking world");
+                    }
+                    catch (Throwable t)
+                    {
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+    
+                    // Spigot End
                     worldserver.addWorldInfoToCrashReport(crashreport);
                     throw new ReportedException(crashreport);
                 }
@@ -622,7 +918,17 @@
                 }
                 catch (Throwable throwable)
                 {
-                    crashreport = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
+                    // Spigot Start
+                    try
+                    {
+                        crashreport = CrashReport.makeCrashReport(throwable, "Exception ticking world entities");
+                    }
+                    catch (Throwable t)
+                    {
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+    
+                    // Spigot End
                     worldserver.addWorldInfoToCrashReport(crashreport);
                     throw new ReportedException(crashreport);
                 }
@@ -630,10 +936,12 @@
                 FMLCommonHandler.instance().onPostWorldTick(worldserver);
                 this.theProfiler.endSection();
                 this.theProfiler.startSection("tracker");
+                worldserver.timings.tracker.startTiming(); // Spigot
                 worldserver.getEntityTracker().updateTrackedEntities();
+                worldserver.timings.tracker.stopTiming(); // Spigot
                 this.theProfiler.endSection();
                 this.theProfiler.endSection();
-            }
+            // } // CraftBukkit
 
             worldTickTimes.get(id)[this.tickCounter % 100] = System.nanoTime() - j;
         }
@@ -641,16 +949,22 @@
         this.theProfiler.endStartSection("dim_unloading");
         DimensionManager.unloadWorlds(worldTickTimes);
         this.theProfiler.endStartSection("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
         this.func_147137_ag().networkTick();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
         this.serverConfigManager.sendPlayerInfoToAllPlayers();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
         this.theProfiler.endStartSection("tickables");
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
 
         for (i = 0; i < this.tickables.size(); ++i)
         {
             ((IUpdatePlayerListBox)this.tickables.get(i)).update();
         }
 
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
         this.theProfiler.endSection();
     }
 
@@ -684,6 +998,13 @@
 
     public WorldServer worldServerForDimension(int par1)
     {
+        // Cauldron start - this is required for MystCraft agebooks to teleport correctly
+        // verify the nether or the end is allowed, and if not return overworld
+        if ((par1 == -1 && !this.getAllowNether()) || (par1 == 1 && !this.server.getAllowEnd()))
+        {
+            return DimensionManager.getWorld(0);
+        }
+        // Cauldron end
         WorldServer ret = DimensionManager.getWorld(par1);
         if (ret == null)
         {
@@ -764,13 +1085,14 @@
 
     public List getPossibleCompletions(ICommandSender par1ICommandSender, String par2Str)
     {
-        ArrayList arraylist = new ArrayList();
+        // Cauldron start - add mod commands to list then pass to bukkit
+        java.util.HashSet arraylist = new java.util.HashSet(); // use a set here to avoid duplicates
 
         if (par2Str.startsWith("/"))
         {
-            par2Str = par2Str.substring(1);
-            boolean flag = !par2Str.contains(" ");
-            List list = this.commandManager.getPossibleCommands(par1ICommandSender, par2Str);
+            String char1 = par2Str.substring(1); // rename var to avoid removing slash from passed message
+            boolean flag = !char1.contains(" ");
+            List list = this.commandManager.getPossibleCommands(par1ICommandSender, char1);
 
             if (list != null)
             {
@@ -778,40 +1100,19 @@
 
                 while (iterator.hasNext())
                 {
-                    String s3 = (String)iterator.next();
+                    String command = (String)iterator.next();
 
                     if (flag)
                     {
-                        arraylist.add("/" + s3);
+                        arraylist.add("/" + command);
                     }
-                    else
-                    {
-                        arraylist.add(s3);
-                    }
                 }
             }
-
-            return arraylist;
         }
-        else
-        {
-            String[] astring = par2Str.split(" ", -1);
-            String s1 = astring[astring.length - 1];
-            String[] astring1 = this.serverConfigManager.getAllUsernames();
-            int i = astring1.length;
 
-            for (int j = 0; j < i; ++j)
-            {
-                String s2 = astring1[j];
-
-                if (CommandBase.doesStringStartWith(s1, s2))
-                {
-                    arraylist.add(s2);
-                }
-            }
-
-            return arraylist;
-        }
+        arraylist.addAll(this.server.tabComplete(par1ICommandSender, par2Str));  // add craftbukkit commands
+        return new ArrayList(arraylist);
+        // Cauldron end
     }
 
     public static MinecraftServer getServer()
@@ -1014,7 +1315,7 @@
 
     public boolean isServerInOnlineMode()
     {
-        return this.onlineMode;
+        return this.server.getOnlineMode(); // CraftBukkit
     }
 
     public void setOnlineMode(boolean par1)
@@ -1104,7 +1405,7 @@
 
     public NetworkSystem func_147137_ag()
     {
-        return this.field_147144_o;
+        return (this.field_147144_o) == null ? this.field_147144_o = new NetworkSystem(this) : this.field_147144_o;     // Spigot
     }
 
     @SideOnly(Side.CLIENT)
@@ -1229,8 +1530,11 @@
     {
         Bootstrap.func_151354_b();
 
+        OptionSet options = loadOptions(par0ArrayOfStr);
+
         try
         {
+            /* CraftBukkit start - Replace everything
             boolean flag = !GraphicsEnvironment.isHeadless();
             String s = null;
             String s1 = ".";
@@ -1326,16 +1630,33 @@
             {
                 dedicatedserver.setGuiEnabled();
             }
+            // */
+            if (CauldronUtils.deobfuscatedEnvironment()) useJline = false; // Cauldron
+            DedicatedServer dedicatedserver = new DedicatedServer(options);
 
-            dedicatedserver.startServerThread();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread")
+            if (options.has("port"))
             {
-                private static final String __OBFID = "CL_00001806";
-                public void run()
+                int port = (Integer) options.valueOf("port");
+
+                if (port > 0)
                 {
-                    dedicatedserver.stopServer();
+                    dedicatedserver.setServerPort(port);
                 }
-            });
+            }
+
+            if (options.has("universe"))
+            {
+                dedicatedserver.anvilFile = (File) options.valueOf("universe");
+            }
+
+            if (options.has("world"))
+            {
+                dedicatedserver.setFolderName((String) options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+            // Runtime.getRuntime().addShutdownHook(new ThreadShutdown("Server Shutdown Thread", dedicatedserver));
+            // CraftBukkit end
         }
         catch (Exception exception)
         {
@@ -1343,6 +1664,203 @@
         }
     }
 
+    public static OptionSet loadOptions(String[] args) {
+        OptionParser parser = new OptionParser() {
+            {
+                acceptsAll(Arrays.asList("?", "help"), "Show the help");
+
+                acceptsAll(Arrays.asList("c", "config"), "Properties file to use")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("server.properties"))
+                        .describedAs("Properties file");
+
+                acceptsAll(Arrays.asList("P", "plugins"), "Plugin directory to use")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("plugins"))
+                        .describedAs("Plugin directory");
+
+                acceptsAll(Arrays.asList("h", "host", "server-ip"), "Host to listen on")
+                        .withRequiredArg()
+                        .ofType(String.class)
+                        .describedAs("Hostname or IP");
+
+                acceptsAll(Arrays.asList("W", "world-dir", "universe", "world-container"), "World container")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .describedAs("Directory containing worlds");
+
+                acceptsAll(Arrays.asList("w", "world", "level-name"), "World name")
+                        .withRequiredArg()
+                        .ofType(String.class)
+                        .describedAs("World name");
+
+                acceptsAll(Arrays.asList("p", "port", "server-port"), "Port to listen on")
+                        .withRequiredArg()
+                        .ofType(Integer.class)
+                        .describedAs("Port");
+
+                acceptsAll(Arrays.asList("o", "online-mode"), "Whether to use online authentication")
+                        .withRequiredArg()
+                        .ofType(Boolean.class)
+                        .describedAs("Authentication");
+
+                acceptsAll(Arrays.asList("s", "size", "max-players"), "Maximum amount of players")
+                        .withRequiredArg()
+                        .ofType(Integer.class)
+                        .describedAs("Server size");
+
+                acceptsAll(Arrays.asList("d", "date-format"), "Format of the date to display in the console (for log entries)")
+                        .withRequiredArg()
+                        .ofType(SimpleDateFormat.class)
+                        .describedAs("Log date format");
+
+                acceptsAll(Arrays.asList("log-pattern"), "Specfies the log filename pattern")
+                        .withRequiredArg()
+                        .ofType(String.class)
+                        .defaultsTo("server.log")
+                        .describedAs("Log filename");
+
+                acceptsAll(Arrays.asList("log-limit"), "Limits the maximum size of the log file (0 = unlimited)")
+                        .withRequiredArg()
+                        .ofType(Integer.class)
+                        .defaultsTo(0)
+                        .describedAs("Max log size");
+
+                acceptsAll(Arrays.asList("log-count"), "Specified how many log files to cycle through")
+                        .withRequiredArg()
+                        .ofType(Integer.class)
+                        .defaultsTo(1)
+                        .describedAs("Log count");
+
+                acceptsAll(Arrays.asList("log-append"), "Whether to append to the log file")
+                        .withRequiredArg()
+                        .ofType(Boolean.class)
+                        .defaultsTo(true)
+                        .describedAs("Log append");
+
+                acceptsAll(Arrays.asList("log-strip-color"), "Strips color codes from log file");
+
+                acceptsAll(Arrays.asList("b", "bukkit-settings"), "File for bukkit settings")
+                        .withRequiredArg()
+                        .ofType(File.class)
+                        .defaultsTo(new File("bukkit.yml"))
+                        .describedAs("Yml file");
+
+                acceptsAll(Arrays.asList("C", "commands-settings"), "File for command settings")
+                         .withRequiredArg()
+                         .ofType(File.class)
+                         .defaultsTo(new File("commands.yml"))
+                         .describedAs("Yml file");
+
+                acceptsAll(Arrays.asList("nojline"), "Disables jline and emulates the vanilla console");
+
+                acceptsAll(Arrays.asList("noconsole"), "Disables the console");
+
+                acceptsAll(Arrays.asList("v", "version"), "Show the CraftBukkit Version");
+
+                acceptsAll(Arrays.asList("demo"), "Demo mode");
+            }
+        };
+
+        OptionSet options = null;
+
+        try {
+            options = parser.parse(args);
+        } catch (joptsimple.OptionException ex) {
+            logger.log(org.apache.logging.log4j.Level.ERROR, ex.getLocalizedMessage());
+        }
+
+        if ((options == null) || (options.has("?"))) {
+            try {
+                parser.printHelpOn(System.out);
+            } catch (IOException ex) {
+                logger.log(org.apache.logging.log4j.Level.ERROR, ex);
+            }
+        } else {
+            try {
+                // This trick bypasses Maven Shade's clever rewriting of our getProperty call when using String literals
+                String jline_UnsupportedTerminal = new String(new char[] {'j','l','i','n','e','.','U','n','s','u','p','p','o','r','t','e','d','T','e','r','m','i','n','a','l'});
+                String jline_terminal = new String(new char[] {'j','l','i','n','e','.','t','e','r','m','i','n','a','l'});
+
+                useJline = !(jline_UnsupportedTerminal).equals(System.getProperty(jline_terminal));
+
+                if (options.has("nojline")) {
+                    System.setProperty("user.language", "en");
+                    useJline = false;
+                }
+
+                if (!useJline) {
+                    // This ensures the terminal literal will always match the jline implementation
+                    System.setProperty(jline.TerminalFactory.JLINE_TERMINAL, jline.UnsupportedTerminal.class.getName());
+                }
+
+
+                if (options.has("noconsole")) {
+                    useConsole = false;
+                }
+                // Cauldron start - initialize config
+                configFile = (File) options.valueOf("bukkit-settings");
+                commandFile = (File)options.valueOf("commands-settings");
+                configuration = YamlConfiguration.loadConfiguration(configFile);
+                configuration.options().copyDefaults(true);
+                configuration.setDefaults(YamlConfiguration.loadConfiguration(MinecraftServer.class.getClassLoader().getResourceAsStream("configurations/bukkit.yml")));
+                ConfigurationSection legacyAlias = null;
+                if (!configuration.isString("aliases")) {
+                    legacyAlias = configuration.getConfigurationSection("aliases");
+                    configuration.set("aliases", "now-in-commands.yml");
+                }
+                try {
+                    configuration.save(configFile);
+                    } catch (IOException ex) {
+                        logger.log(org.apache.logging.log4j.Level.ERROR, "Could not save " + configFile, ex);
+                }
+                if (commandFile.isFile()) {
+                    legacyAlias = null;
+                }
+                commandsConfiguration = YamlConfiguration.loadConfiguration(commandFile);
+                commandsConfiguration.options().copyDefaults(true);
+                commandsConfiguration.setDefaults(YamlConfiguration.loadConfiguration(MinecraftServer.class.getClassLoader().getResourceAsStream("configurations/commands.yml")));
+                try {
+                    commandsConfiguration.save(commandFile);
+                    } catch (IOException ex) {
+                        logger.log(org.apache.logging.log4j.Level.ERROR, "Could not save " + commandFile, ex);
+                }
+
+                // Migrate aliases from old file and add previously implicit $1- to pass all arguments
+                if (legacyAlias != null) {
+                    ConfigurationSection aliases = commandsConfiguration.createSection("aliases");
+                    for (String key : legacyAlias.getKeys(false)) {
+                        ArrayList<String> commands = new ArrayList<String>();
+
+                        if (legacyAlias.isList(key)) {
+                            for (String command : legacyAlias.getStringList(key)) {
+                                commands.add(command + " $1-");
+                            }
+                        } else {
+                            commands.add(legacyAlias.getString(key) + " $1-");
+                        }
+
+                        aliases.set(key, commands);
+                    }
+                }
+
+                try {
+                    commandsConfiguration.save(commandFile);
+                    } catch (IOException ex) {
+                        logger.log(org.apache.logging.log4j.Level.ERROR, "Could not save " + commandFile, ex);
+                }
+
+                return options;
+                // Cauldron end
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        }
+        return null; // Cauldron
+    }
+
     @SideOnly(Side.SERVER)
     public void logInfo(String par1Str)
     {
@@ -1370,15 +1888,70 @@
     @SideOnly(Side.SERVER)
     public String getPlugins()
     {
-        return "";
+        // CraftBukkit start - Whole method
+        StringBuilder result = new StringBuilder();
+        org.bukkit.plugin.Plugin[] plugins = server.getPluginManager().getPlugins();
+        result.append(server.getName());
+        result.append(" on Bukkit ");
+        result.append(server.getBukkitVersion());
+
+        if (plugins.length > 0 && this.server.getQueryPlugins())
+        {
+            result.append(": ");
+
+            for (int i = 0; i < plugins.length; i++)
+            {
+                if (i > 0)
+                {
+                    result.append("; ");
+                }
+
+                result.append(plugins[i].getDescription().getName());
+                result.append(" ");
+                result.append(plugins[i].getDescription().getVersion().replaceAll(";", ","));
+            }
+        }
+
+        return result.toString();
+        // CraftBukkit end
     }
 
     @SideOnly(Side.SERVER)
-    public String handleRConCommand(String par1Str)
+    public String handleRConCommand(final String par1Str)
     {
-        RConConsoleSource.instance.resetLog();
-        this.commandManager.executeCommand(RConConsoleSource.instance, par1Str);
-        return RConConsoleSource.instance.getLogContents();
+        Waitable<String> waitable = new Waitable<String>()
+        {
+            @Override
+            protected String evaluate()
+            {
+                RConConsoleSource.instance.resetLog();
+                // Event changes start
+                RemoteServerCommandEvent event = new RemoteServerCommandEvent(MinecraftServer.this.remoteConsole, par1Str);
+                MinecraftServer.this.server.getPluginManager().callEvent(event);
+                // Event changes end
+                ServerCommand servercommand = new ServerCommand(event.getCommand(), RConConsoleSource.instance);
+                MinecraftServer.this.server.dispatchServerCommand(MinecraftServer.this.remoteConsole, servercommand); // CraftBukkit
+                // this.n.a(RemoteControlCommandListener.instance, s);
+                return RConConsoleSource.instance.getLogContents();
+            }
+        };
+        processQueue.add(waitable);
+
+        try
+        {
+            return waitable.get();
+        }
+        catch (java.util.concurrent.ExecutionException e)
+        {
+            throw new RuntimeException("Exception processing rcon command " + par1Str, e.getCause());
+        }
+        catch (InterruptedException e)
+        {
+            Thread.currentThread().interrupt(); // Maintain interrupted state
+            throw new RuntimeException("Interrupted processing rcon command " + par1Str, e);
+        }
+
+        // CraftBukkit end
     }
 
     @SideOnly(Side.SERVER)
@@ -1430,4 +2003,11 @@
     {
         this.isGamemodeForced = par1;
     }
+
+    // CraftBukkit start
+    public static Logger getLogger()
+    {
+        return logger;
+    }
+    // CraftBukkit end
 }
