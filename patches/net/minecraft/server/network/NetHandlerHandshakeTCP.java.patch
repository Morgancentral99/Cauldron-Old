--- ../src-base/minecraft/net/minecraft/server/network/NetHandlerHandshakeTCP.java
+++ ../src-work/minecraft/net/minecraft/server/network/NetHandlerHandshakeTCP.java
@@ -2,16 +2,29 @@
 
 import io.netty.util.concurrent.GenericFutureListener;
 import net.minecraft.network.EnumConnectionState;
+import net.minecraft.network.INetHandler;
 import net.minecraft.network.NetworkManager;
 import net.minecraft.network.handshake.INetHandlerHandshakeServer;
 import net.minecraft.network.handshake.client.C00Handshake;
 import net.minecraft.network.login.server.S00PacketDisconnect;
 import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.dedicated.DedicatedServer;
 import net.minecraft.util.ChatComponentText;
 import net.minecraft.util.IChatComponent;
 
+
+// CraftBukkit start
+import java.net.InetAddress;
+import java.util.HashMap;
+// CraftBukkit end
+
 public class NetHandlerHandshakeTCP implements INetHandlerHandshakeServer
 {
+    // CraftBukkit start
+    private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    private static int throttleCounter = 0;
+    // CraftBukkit end
+
     private final MinecraftServer field_147387_a;
     private final NetworkManager field_147386_b;
     private static final String __OBFID = "CL_00001456";
@@ -25,27 +38,102 @@
     // JAVADOC METHOD $$ func_147383_a
     public void processHandshake(C00Handshake p_147383_1_)
     {
+        // MCPC+ start - prevent players from logging in before server has fully started. This fixes inventory wipe glitches.
+        if (!DedicatedServer.allowPlayerLogins)
+        {
+            ChatComponentText chatcomponenttext = new ChatComponentText("Server is still starting! Please wait before reconnecting.");
+            this.field_147386_b.scheduleOutboundPacket(new S00PacketDisconnect(chatcomponenttext), new GenericFutureListener[0]);
+            this.field_147386_b.closeChannel(chatcomponenttext); // Should be close
+            return;
+        }
+        // MCPC+ end
         switch (NetHandlerHandshakeTCP.SwitchEnumConnectionState.field_151291_a[p_147383_1_.func_149594_c().ordinal()])
         {
             case 1:
                 this.field_147386_b.setConnectionState(EnumConnectionState.LOGIN);
                 ChatComponentText chatcomponenttext;
 
+                // CraftBukkit start
+                try
+                {
+                    long currentTime = System.currentTimeMillis();
+                    long connectionThrottle = MinecraftServer.getServer().server.getConnectionThrottle();
+                    InetAddress address = ((java.net.InetSocketAddress) this.field_147386_b.getSocketAddress()).getAddress();
+
+                    synchronized (throttleTracker)
+                    {
+                        if (throttleTracker.containsKey(address) && !"127.0.0.1".equals(address.getHostAddress()) && currentTime - throttleTracker.get(address) < connectionThrottle)
+                        {
+                            throttleTracker.put(address, currentTime);
+                            chatcomponenttext = new ChatComponentText("Connection throttled! Please wait before reconnecting.");
+                            this.field_147386_b.scheduleOutboundPacket(new S00PacketDisconnect(chatcomponenttext), new GenericFutureListener[0]);
+                            this.field_147386_b.closeChannel(chatcomponenttext); // Should be close
+                            return;
+                        }
+
+                        throttleTracker.put(address, currentTime);
+                        throttleCounter++;
+
+                        if (throttleCounter > 200)
+                        {
+                            throttleCounter = 0;
+                            // Cleanup stale entries
+                            java.util.Iterator iter = throttleTracker.entrySet().iterator();
+
+                            while (iter.hasNext())
+                            {
+                                java.util.Map.Entry<InetAddress, Long> entry = (java.util.Map.Entry) iter.next();
+
+                                if (entry.getValue() > connectionThrottle)
+                                {
+                                    iter.remove();
+                                }
+                            }
+                        }
+                    }
+                }
+                catch (Throwable t)
+                {
+                    org.apache.logging.log4j.LogManager.getLogger().error("Failed to check connection throttle", t);
+                }
+
+                // CraftBukkit end
+
                 if (p_147383_1_.func_149595_d() > 4)
                 {
-                    chatcomponenttext = new ChatComponentText("Outdated server! I\'m still on 1.7.2");
+                    chatcomponenttext = new ChatComponentText(org.spigotmc.SpigotConfig.outdatedServerMessage);   // Spigot
                     this.field_147386_b.scheduleOutboundPacket(new S00PacketDisconnect(chatcomponenttext), new GenericFutureListener[0]);
                     this.field_147386_b.closeChannel(chatcomponenttext);
                 }
                 else if (p_147383_1_.func_149595_d() < 4)
                 {
-                    chatcomponenttext = new ChatComponentText("Outdated client! Please use 1.7.2");
+                    chatcomponenttext = new ChatComponentText(org.spigotmc.SpigotConfig.outdatedClientMessage);   // Spigot
                     this.field_147386_b.scheduleOutboundPacket(new S00PacketDisconnect(chatcomponenttext), new GenericFutureListener[0]);
                     this.field_147386_b.closeChannel(chatcomponenttext);
                 }
                 else
                 {
-                    this.field_147386_b.setNetHandler(new NetHandlerLoginServer(this.field_147387_a, this.field_147386_b));
+                    this.field_147386_b.setNetHandler((new NetHandlerLoginServer(this.field_147387_a, this.field_147386_b)));
+
+                    // Spigot Start
+                    if (org.spigotmc.SpigotConfig.bungee)
+                    {
+                        String[] split = p_147383_1_.field_149598_b.split("\00");
+
+                        if (split.length == 2 || split.length == 3)
+                        {
+                            p_147383_1_.field_149598_b = split[0];
+                            field_147386_b.socketAddress = new java.net.InetSocketAddress(split[1], ((java.net.InetSocketAddress) field_147386_b.getSocketAddress()).getPort());
+                        }
+
+                        if (split.length == 3)
+                        {
+                            field_147386_b.spoofedUUID = split[2];
+                        }
+                    }
+
+                    // Spigot End
+                    ((NetHandlerLoginServer) this.field_147386_b.getNetHandler()).hostname = p_147383_1_.field_149598_b + ":" + p_147383_1_.field_149599_c; // CraftBukkit - set hostname
                 }
 
                 break;
