--- ../src_base/minecraft/net/minecraft/item/ItemStack.java
+++ ../src_work/minecraft/net/minecraft/item/ItemStack.java
@@ -20,6 +20,7 @@
 import net.minecraft.entity.ai.attributes.AttributeModifier;
 import net.minecraft.entity.item.EntityItemFrame;
 import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.nbt.NBTBase;
 import net.minecraft.nbt.NBTTagCompound;
 import net.minecraft.nbt.NBTTagList;
@@ -29,6 +30,7 @@
 import net.minecraft.util.Icon;
 import net.minecraft.util.StatCollector;
 import net.minecraft.world.World;
+import net.minecraftforge.event.ForgeEventFactory;
 
 public final class ItemStack
 {
@@ -53,8 +55,12 @@
     /** Damage dealt to the item or number of use. Raise when using items. */
     int itemDamage;
 
+    // MCPC+ - due to a bug in Gson(https://code.google.com/p/google-gson/issues/detail?id=440), a stackoverflow 
+    //         can occur when gson attempts to resolve a field of a class that points to itself.
+    //         As a temporary workaround, we will prevent serialization for this object until the bug is fixed.
+    //         This fixes EE3's serialization of ItemStack.
     /** Item frame this stack is on, or null if not on an item frame. */
-    private EntityItemFrame itemFrame;
+    private transient EntityItemFrame itemFrame;
 
     public ItemStack(Block par1Block)
     {
@@ -128,6 +134,7 @@
      */
     public Item getItem()
     {
+        if (this.itemID < 0) return null; // MCPC+
         return Item.itemsList[this.itemID];
     }
 
@@ -149,12 +156,48 @@
 
     public boolean tryPlaceItemIntoWorld(EntityPlayer par1EntityPlayer, World par2World, int par3, int par4, int par5, int par6, float par7, float par8, float par9)
     {
-        boolean flag = this.getItem().onItemUse(this, par1EntityPlayer, par2World, par3, par4, par5, par6, par7, par8, par9);
+        // MCPC+ start - handle all placement events here
+        boolean flag = false;
+        int meta = this.getItemDamage();
+        int size = this.stackSize;
+        par2World.captureBlocks = true;
+        flag = this.getItem().onItemUse(this, par1EntityPlayer, par2World, par3, par4, par5, par6, par7, par8, par9);
+        par2World.captureBlocks = false;
 
         if (flag)
         {
-            par1EntityPlayer.addStat(StatList.objectUseStats[this.itemID], 1);
-        }
+            boolean isCancelled = false;
+            for (int i = 0; i < par2World.capturedBlocks.size(); i++)
+            {
+                org.bukkit.event.block.BlockPlaceEvent placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(par2World, par1EntityPlayer, par2World.capturedBlocks.get(i), par3, par4, par5);
+
+                if (placeEvent.isCancelled() || !placeEvent.canBuild())
+                {
+                    isCancelled = true;
+                    break;
+                }
+            }
+            if (isCancelled)
+            {
+                flag = false; // cancel placement
+                // revert back all captured blocks
+                for (int i = 0; i < par2World.capturedBlocks.size(); i++)
+                {
+                    par2World.restoringBlockStates = true;
+                    par2World.capturedBlocks.get(i).update(true, false); // restore blockstate
+                    par2World.restoringBlockStates = false;
+                }
+                // make sure to restore stack after cancel
+                this.setItemDamage(meta);
+                this.stackSize = size;
+            }
+            else
+            {
+                par1EntityPlayer.addStat(StatList.objectUseStats[this.itemID], 1);
+            }
+        }
+        par2World.capturedBlocks.clear();
+        // MCPC+ end
 
         return flag;
     }
@@ -192,7 +235,7 @@
 
         if (this.stackTagCompound != null)
         {
-            par1NBTTagCompound.setTag("tag", this.stackTagCompound);
+            par1NBTTagCompound.setTag("tag", this.stackTagCompound.copy()); // CraftBukkit - make defensive copy, data is going to another thread
         }
 
         return par1NBTTagCompound;
@@ -214,7 +257,8 @@
 
         if (par1NBTTagCompound.hasKey("tag"))
         {
-            this.stackTagCompound = par1NBTTagCompound.getCompoundTag("tag");
+            // CraftBukkit - make defensive copy as this data may be coming from the save thread
+            this.stackTagCompound = (NBTTagCompound) par1NBTTagCompound.getCompoundTag("tag").copy();
         }
     }
 
@@ -223,7 +267,7 @@
      */
     public int getMaxStackSize()
     {
-        return this.getItem().getItemStackLimit();
+        return this.getItem().getItemStackLimit(this);
     }
 
     /**
@@ -239,7 +283,7 @@
      */
     public boolean isItemStackDamageable()
     {
-        return Item.itemsList[this.itemID].getMaxDamage() > 0;
+        return Item.itemsList[this.itemID].getMaxDamage(this) > 0;
     }
 
     public boolean getHasSubtypes()
@@ -252,7 +296,9 @@
      */
     public boolean isItemDamaged()
     {
-        return this.isItemStackDamageable() && this.itemDamage > 0;
+        boolean damaged = itemDamage > 0;
+        if (getItem() != null) damaged = getItem().isDamaged(this);
+        return this.isItemStackDamageable() && damaged;
     }
 
     /**
@@ -260,6 +306,10 @@
      */
     public int getItemDamageForDisplay()
     {
+        if (getItem() != null)
+        {
+            return getItem().getDisplayDamage(this);
+        }
         return this.itemDamage;
     }
 
@@ -268,6 +318,10 @@
      */
     public int getItemDamage()
     {
+        if (getItem() != null)
+        {
+            return getItem().getDamage(this);
+        }
         return this.itemDamage;
     }
 
@@ -276,6 +330,12 @@
      */
     public void setItemDamage(int par1)
     {
+        if (getItem() != null)
+        {
+            getItem().setDamage(this, par1);
+            return;
+        }
+
         this.itemDamage = par1;
 
         if (this.itemDamage < 0)
@@ -289,7 +349,7 @@
      */
     public int getMaxDamage()
     {
-        return Item.itemsList[this.itemID].getMaxDamage();
+        return this.getItem().getMaxDamage(this);
     }
 
     /**
@@ -298,8 +358,15 @@
      * getMaxDamage(). Returns false otherwise or if the ItemStack can't be damaged or if all points of damage are
      * negated.
      */
+    // Spigot start
     public boolean attemptDamageItem(int par1, Random par2Random)
     {
+        return isDamaged(par1, par2Random, null);
+    }
+
+    public boolean isDamaged(int par1, Random par2Random, EntityLivingBase entitylivingbase)
+    {
+        // Spigot end
         if (!this.isItemStackDamageable())
         {
             return false;
@@ -321,14 +388,29 @@
 
                 par1 -= k;
 
+                // Spigot start
+                if (entitylivingbase instanceof EntityPlayerMP)
+                {
+                    org.bukkit.craftbukkit.inventory.CraftItemStack item = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(this);
+                    org.bukkit.event.player.PlayerItemDamageEvent event = new org.bukkit.event.player.PlayerItemDamageEvent((org.bukkit.entity.Player) entitylivingbase.getBukkitEntity(), item, par1);
+                    org.bukkit.Bukkit.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled())
+                    {
+                        return false;
+                    }
+
+                    par1 = event.getDamage();
+                }
+
                 if (par1 <= 0)
                 {
                     return false;
                 }
             }
 
-            this.itemDamage += par1;
-            return this.itemDamage > this.getMaxDamage();
+            setItemDamage(getItemDamage() + par1); //Redirect through Item's callback if applicable.
+            return getItemDamage() > getMaxDamage();
         }
     }
 
@@ -362,6 +444,13 @@
                         this.stackSize = 0;
                     }
 
+                    // CraftBukkit start - Check for item breaking
+                    if (this.stackSize == 0 && par2EntityLivingBase instanceof EntityPlayer)
+                    {
+                        org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerItemBreakEvent((EntityPlayer) par2EntityLivingBase, this);
+                    }
+
+                    // CraftBukkit end
                     this.itemDamage = 0;
                 }
             }
@@ -396,7 +485,7 @@
      */
     public boolean canHarvestBlock(Block par1Block)
     {
-        return Item.itemsList[this.itemID].canHarvestBlock(par1Block);
+        return Item.itemsList[this.itemID].canHarvestBlock(par1Block, this);
     }
 
     public boolean func_111282_a(EntityPlayer par1EntityPlayer, EntityLivingBase par2EntityLivingBase)
@@ -478,7 +567,15 @@
             --this.animationsToGo;
         }
 
-        Item.itemsList[this.itemID].onUpdate(this, par1World, par2Entity, par3, par4);
+        // MCPC+ start - print exception instead of kicking client (if they have a corrupted item in their inventory)
+        try {
+            Item.itemsList[this.itemID].onUpdate(this, par1World, par2Entity, par3, par4);
+        } catch (Throwable ex) {
+            System.out.println("updateAnimation exception");
+            ex.printStackTrace();
+            return;
+        }
+        // MCPC+ end
     }
 
     public void onCrafting(World par1World, EntityPlayer par2EntityPlayer, int par3)
@@ -531,6 +628,13 @@
      */
     public void setTagCompound(NBTTagCompound par1NBTTagCompound)
     {
+        // CraftBukkit start - Set compound name to "tag," remove discrepancy
+        if (par1NBTTagCompound != null)
+        {
+            par1NBTTagCompound.setName("tag");
+        }
+
+        // CraftBukkit end
         this.stackTagCompound = par1NBTTagCompound;
     }
 
@@ -733,14 +837,21 @@
         {
             arraylist.add("Durability: " + (this.getMaxDamage() - this.getItemDamageForDisplay()) + " / " + this.getMaxDamage());
         }
+        ForgeEventFactory.onItemTooltip(this, par1EntityPlayer, arraylist, par2);
 
         return arraylist;
     }
 
+    @Deprecated
     @SideOnly(Side.CLIENT)
     public boolean hasEffect()
     {
-        return this.getItem().hasEffect(this);
+        return hasEffect(0);
+    }
+    @SideOnly(Side.CLIENT)
+    public boolean hasEffect(int pass)
+    {
+        return this.getItem().hasEffect(this, pass);
     }
 
     @SideOnly(Side.CLIENT)
